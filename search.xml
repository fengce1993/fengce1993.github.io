<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络(七)：应用层</title>
      <link href="/2020/02/06/network-6/"/>
      <url>/2020/02/06/network-6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-域名系统-dns"><a class="markdownIt-Anchor" href="#1-域名系统-dns"></a> 1 域名系统 DNS</h2><h3 id="11-域名系统概述"><a class="markdownIt-Anchor" href="#11-域名系统概述"></a> 1.1 域名系统概述</h3><p>许多应用层软件经常直接使用域名系统 DNS，但计算机的用户只是间接而不是直接使用域名系统。</p><p>因特网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统 DNS。</p><p>名字到 IP 地址的解析是由若干个域名服务器程序完成的。域名服务器程序在专设的结点上运行，运行该程序的机器称为<strong>域名服务器</strong>。</p><p><strong>应用层协议的特点</strong></p><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决又往往是通过位于不同主机中的多个应用进程之间的通信和协同工作来完成的。应用层的具体内容就是规定应用进程在通信时所遵循的协议。</p><p>应用层的许多协议都是基于客户服务器方式。客户和服务器都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务请求方，服务器是服务提供方。</p><h3 id="12-因特网的域名结构"><a class="markdownIt-Anchor" href="#12-因特网的域名结构"></a> 1.2 因特网的域名结构</h3><p>因特网采用了层次树状结构的命名方法。</p><p>任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名。</p><p>域名的结构由标号序列组成，各标号之间用点隔开：</p><pre class="highlight"><code class>... .三级域名.二级域名.顶级域名</code></pre><p>各标号分别代表不同级别的域名。</p><p><strong>域名只是个逻辑概念</strong></p><p>域名只是个逻辑概念，并不代表计算机所在的物理地点。</p><p>变长的域名和使用有助记忆的字符串，是为了便于人来使用。而 IP 地址是定长的 32 位二进制数字则非常便于机器进行处理。</p><p>域名中的“点”和点分十进制 IP 地址中的“点”并无一一对应的关系。点分十进制 IP 地址中一定是包含三个“点”，但每一个域名中“点”的数目则不一定正好是三个。</p><p><a href="/pic/network/6-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-1.png" class="lazyload"></a></p><h3 id="13-域名服务器"><a class="markdownIt-Anchor" href="#13-域名服务器"></a> 1.3 域名服务器</h3><p>一个服务器所负责管辖的（或有权限的）范围叫做<strong>区</strong>(zone)。</p><p>各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。</p><p>每一个区设置相应的<strong>权限域名服务器</strong>，用来保存该区中的所有主机的域名到IP地址的映射。</p><p>DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。</p><p><strong>区的不同划分方法举例</strong></p><p><a href="/pic/network/6-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-2.png" class="lazyload"></a></p><hr><p><strong>树状结构的 DNS 域名服务器</strong></p><p><a href="/pic/network/6-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-3.png" class="lazyload"></a></p><p>域名服务器有以下四种类型：</p><ol><li>根域名服务器</li><li>顶级域名服务器</li><li>权限域名服务器</li><li>本地域名服务器</li></ol><hr><p><strong>根域名服务器</strong>：最高层次的域名服务器</p><ul><li>根域名服务器是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。</li><li>不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析，只要自己无法解析，就首先求助于根域名服务器。</li><li>在因特网上共有13 个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母）。</li></ul><p>根域名服务器共有 13 套装置，不是 13 个机器。</p><p>这些根域名服务器相应的域名分别是</p><ul><li><a href="http://a.rootservers.net" target="_blank" rel="noopener">a.rootservers.net</a></li><li><a href="http://b.rootservers.net" target="_blank" rel="noopener">b.rootservers.net</a></li><li>…</li><li><a href="http://m.rootservers.net" target="_blank" rel="noopener">m.rootservers.net</a></li></ul><p>到 2006 年底全世界已经安装了一百多个根域名服务器机器，分布在世界各地。这样做的目的是为了方便用户，使世界上大部分 DNS 域名服务器都能<strong>就近</strong>找到一个根域名服务器。</p><p>根域名服务器并不直接把域名直接转换成 IP 地址。在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器。</p><p><strong>顶级域名服务器</strong></p><p>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。</p><p>当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址）。</p><p><strong>权限域名服务器</strong></p><p>这就是前面已经讲过的负责一个区的域名服务器。</p><p>当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的 DNS 客户，下一步应当找哪一个权限域名服务器。</p><p><strong>本地域名服务器</strong></p><p>本地域名服务器对域名系统非常重要。</p><p>当一个主机发出 DNS 查询请求时，这个查询请求报文就发送给本地域名服务器。</p><p>每一个因特网服务提供者 ISP，或一个大学，甚至一个大学里的系，都可以拥有一个本地域名服务器，这种域名服务器有时也称为默认域名服务器。</p><hr><p><strong>提高域名服务器的可靠性</strong></p><p>DNS 域名服务器都把数据复制到几个域名服务器来保存，其中的一个是<strong>主域名服务器</strong>，其他的是<strong>辅助域名服务器</strong>。</p><p>当主域名服务器出故障时，辅助域名服务器可以保证 DNS 的查询工作不会中断。</p><p>主域名服务器定期把数据复制到辅助域名服务器中，而更改数据只能在主域名服务器中进行。这样就保证了数据的一致性。</p><hr><p><strong>域名的解析过程</strong></p><p>主机向本地域名服务器的查询一般都是采用<strong>递归查询</strong>。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。</p><p>本地域名服务器向根域名服务器的查询通常是采用<strong>迭代查询</strong>。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。</p><p><a href="/pic/network/6-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-4.png" class="lazyload"></a></p><p><strong>域名的高速缓存</strong></p><p>每个域名服务器都维护一个高速缓存，存放最近用过的名字以及从何处获得名字映射信息的记录。</p><p>可大大减轻根域名服务器的负荷，使因特网上的 DNS 查询请求和回答报文的数量大为减少。</p><p>为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器，并处理超过合理时间的项（例如，每个项目只存放两天）。</p><p>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名转换的准确性。</p><h2 id="2-文件传送协议"><a class="markdownIt-Anchor" href="#2-文件传送协议"></a> 2 文件传送协议</h2><h3 id="21-ftp概述"><a class="markdownIt-Anchor" href="#21-ftp概述"></a> 2.1 FTP概述</h3><p>文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。</p><p>FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。</p><p>FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。</p><p>RFC 959 很早就成为了因特网的正式标准。</p><p><strong>文件传送并非很简单的问题</strong></p><p>网络环境中的一项基本应用就是将文件从一台计算机中复制到另一台可能相距很远的计算机中。初看起来，在两个主机之间传送文件是很简单的事情。其实这往往非常困难。原因是众多的计算机厂商研制出的文<strong>件系统多达数百种，且差别很大</strong>。</p><h3 id="22-ftp-的基本工作原理"><a class="markdownIt-Anchor" href="#22-ftp-的基本工作原理"></a> 2.2 FTP 的基本工作原理</h3><p>网络环境下复制文件的复杂性：</p><ol><li>计算机存储数据的格式不同。</li><li>文件的目录结构和文件命名的规定不同。</li><li>对于相同的文件存取功能，操作系统使用的命令不同。</li><li>访问控制方法不同。</li></ol><p><strong>FTP 特点</strong></p><ul><li>文件传送协议 FTP 只提供文件传送的一些基本的服务，它使用 TCP 可靠的运输服务。</li><li>FTP 的主要功能是减少或消除在不同操作系统下处理文件的不兼容性。</li><li>FTP 使用<strong>客户服务器方式</strong>。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个<strong>主进程</strong>，负责接受新的请求；另外有若干个<strong>从属进程</strong>，负责处理单个请求。</li></ul><p><strong>主进程的工作步骤</strong></p><ol><li>打开熟知端口（端口号为 21），使客户进程能够连接上。</li><li>等待客户进程发出连接请求。</li><li>启动从属进程来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。</li><li>回到等待状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。</li></ol><p><strong>两个连接</strong></p><p><strong>控制连接</strong>在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件。</p><p>实际用于传输文件的是“<strong>数据连接</strong>”。服务器端的控制进程在接收到 FTP 客户发送来的文件传输请求后就创建“数据传送进程”和“数据连接”，用来连接客户端和服务器端的数据传送进程。</p><p>数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。</p><p><a href="/pic/network/6-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-5.png" class="lazyload"></a></p><p><strong>两个不同的端口号</strong></p><ol><li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的熟知端口(21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。</li><li>接着，服务器进程用自己传送数据的熟知端口(20)与客户进程所提供的端口号码建立数据传送连接。</li></ol><p>由于 FTP 使用了两个不同的端口号，所以数据连接与控制连接不会发生混乱。</p><p><strong>使用两个不同端口号的好处</strong></p><ul><li>使协议更加简单和更容易实现。</li><li>在传输文件时还可以利用控制连接（例如，客户发送请求终止传输）。</li></ul><p><strong>NFS 采用另一种思路</strong></p><ul><li>NFS 允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据。</li><li>NFS 可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件。</li><li>对于上述例子，计算机 A 的 NFS 客户软件，把要添加的数据和在文件后面写数据的请求一起发送到远地的计算机 B 的 NFS 服务器。NFS 服务器更新文件后返回应答信息。</li><li>在网络上传送的只是少量的修改数据。</li></ul><h3 id="23-简单文件传送协议-tftp"><a class="markdownIt-Anchor" href="#23-简单文件传送协议-tftp"></a> 2.3 简单文件传送协议 TFTP</h3><p>TFTP 是一个很小且易于实现的文件传送协议。</p><p>TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。</p><p>TFTP 只支持文件传输而不支持交互。</p><p>TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。</p><p><strong>TFTP 的主要特点</strong></p><ul><li>每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。</li><li>数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。</li><li>支持 ASCII 码或二进制传送。</li><li>可对文件进行读或写。</li><li>使用很简单的首部。</li></ul><p><strong>TFTP 的工作很像停止等待协议</strong></p><ol><li>发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号。</li><li>发完数据后在规定时间内收不到确认就要重发数据 PDU。</li><li>发送确认 PDU 的一方若在规定时间内收不到下一个文件块，也要重发确认 PDU。这样就可保证文件的传送不致因某一个数据报的丢失而告失败。</li><li>在一开始工作时。TFTP 客户进程发送一个读请求 PDU 或写请求 PDU 给 TFTP 服务器进程，其熟知端口号码为 69。</li><li>TFTP 服务器进程要选择一个新的端口和 TFTP 客户进程进行通信。</li><li>若文件长度恰好为 512 字节的整数倍，则在文件传送完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU。</li><li>若文件长度不是 512 字节的整数倍，则最后传送数据 PDU 的数据字段一定不满512字节，这正好可作为文件结束的标志。</li></ol><h2 id="3-远程终端协议-telnet"><a class="markdownIt-Anchor" href="#3-远程终端协议-telnet"></a> 3 远程终端协议 TELNET</h2><p>TELNET 是一个简单的远程终端协议，也是因特网的正式标准。</p><p>用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。</p><p>TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。</p><p><strong>客户服务器方式</strong></p><p>现在由于 PC 机的功能越来越强，用户已较少使用 TELNET 了。</p><p>TELNET 也使用客户服务器方式。在本地系统运行 TELNET 客户进程，而在远地主机则运行 TELNET 服务器进程。</p><p>和 FTP 的情况相似，服务器中的主进程等待新的请求，并产生从属进程来处理每一个连接。</p><p><a href="/pic/network/6-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-6.png" class="lazyload"></a></p><p><strong>网络虚拟终端 NVT 格式</strong></p><p>客户软件把用户的击键和命令转换成 NVT 格式，并送交服务器。</p><p>服务器软件把收到的数据和命令，从 NVT 格式转换成远地系统所需的格式。</p><p>向用户返回数据时，服务器把远地系统的格式转换为 NVT 格式，本地客户再从 NVT 格式转换到本地系统所需的格式。</p><h2 id="4-万维网-www"><a class="markdownIt-Anchor" href="#4-万维网-www"></a> 4 万维网 WWW</h2><h3 id="41-万维网概述"><a class="markdownIt-Anchor" href="#41-万维网概述"></a> 4.1 万维网概述</h3><p>万维网 WWW (World Wide Web)并非某种特殊的计算机网络。万维网是一个大规模的、联机式的信息储藏所。</p><p>万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。这种访问方式称为“<strong>链接</strong>”。</p><p><strong>万维网提供分布式服务</strong></p><p><a href="/pic/network/6-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-7.png" class="lazyload"></a></p><p><strong>超媒体与超文本</strong></p><ul><li>万维网是<strong>分布式超媒体</strong>(hypermedia)系统，它是<strong>超文本</strong>(hypertext)系统的扩充。</li><li>一个超文本由多个信息源链接成。利用一个链接可使用户找到另一个文档。这些文档可以位于世界上任何一个接在因特网上的超文本系统中。超文本是万维网的基础。</li><li>超媒体与超文本的区别是<strong>文档内容不同</strong>。超文本文档仅包含文本信息，而超媒体文档还包含其他表示方式的信息，如图形、图像、声音、动画，甚至活动视频图像。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以客户服务器方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的万维网文档。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong>(page)。</li></ul><hr><p><strong>万维网必须解决的问题</strong></p><p>（1）怎样标志分布在整个因特网上的万维网文档？</p><ul><li>使用<strong>统一资源定位符 URL</strong> (Uniform Resource Locator)来标志万维网上的各种文档。</li><li>使每一个文档在整个因特网的范围内具有唯一的标识符 URL。</li></ul><p>（2）用何协议实现万维网上各种超链的链接？</p><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议 HTTP</strong> (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p>（3）怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？</p><p>超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。</p><p>（4）怎样使用户能够很方便地找到所需的信息？</p><p>为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。</p><h3 id="42-统一资源定位符-url"><a class="markdownIt-Anchor" href="#42-统一资源定位符-url"></a> 4.2 统一资源定位符 URL</h3><p>统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。</p><p>URL 给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。</p><p>只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找其属性。</p><p>URL 相当于一个文件名在网络范围的扩展。因此 URL 是与因特网相连的机器上的任何可访问对象的一个指针。</p><p><strong>URL 的一般形式</strong></p><p>由以冒号隔开的两大部分组成，并且在 URL 中的字符对大写或小写没有要求。</p><pre class="highlight"><code class>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; </code></pre><p>协议：ftp —— 文件传送协议 FTP；http —— 超文本传送协议 HTTP；News —— USENET 新闻</p><p>主机：是存放资源的主机在因特网中的域名。</p><p>端口和路径有时可省略。</p><p><strong>使用 HTTP 的 URL</strong></p><pre class="highlight"><code class>http://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; </code></pre><p>其中“😕/”是规定的格式；主机填写域名；HTTP的默认端口是80，通常可以省略；若再省略文件的&lt;路径&gt;选项，则URL就指到因特网的某个主页(home page)。</p><h3 id="43-超文本传送协议-http"><a class="markdownIt-Anchor" href="#43-超文本传送协议-http"></a> 4.3 超文本传送协议 HTTP</h3><h4 id="431-http-的操作过程"><a class="markdownIt-Anchor" href="#431-http-的操作过程"></a> 4.3.1 HTTP 的操作过程</h4><p>为了使超文本的链接能够高效率地完成，需要用 HTTP 协议来传送一切必须的信息。</p><p>从层次的角度看，HTTP 是<strong>面向事务的</strong>应用层协议，它是万维网上能够可靠地交换文件（包括文本、声音、图像等各种多媒体文件）的重要基础。</p><p><strong>万维网的工作过程</strong></p><p><a href="/pic/network/6-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-8.png" class="lazyload"></a></p><p><strong>用户点击鼠标后所发生的事件</strong></p><ol><li>浏览器分析超链指向页面的 URL。</li><li>浏览器向 DNS 请求解析 <a href="http://www.tsinghua.edu.cn" target="_blank" rel="noopener">www.tsinghua.edu.cn</a> 的 IP 地址。</li><li>域名系统 DNS 解析出清华大学服务器的 IP 地址。</li><li>浏览器与服务器建立 TCP 连接</li><li>浏览器发出取文件命令：GET /chn/yxsz/index.htm。</li><li>服务器给出响应，把文件 index.htm 发给浏览器。</li><li>TCP 连接释放。</li><li>浏览器显示“清华大学院系设置”文件 index.htm 中的所有文本。</li></ol><h4 id="432-http-的主要特点"><a class="markdownIt-Anchor" href="#432-http-的主要特点"></a> 4.3.2 HTTP 的主要特点</h4><ul><li>HTTP 是面向事务的客户服务器协议。</li><li>HTTP 1.0 协议是无状态的(stateless)。</li><li>HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。</li></ul><p><strong>请求一个万维网文档所需的时间</strong></p><p><a href="/pic/network/6-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-9.png" class="lazyload"></a></p><p><strong>持续连接</strong></p><p>HTTP/1.1 协议使用持续连接。</p><p>万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。</p><p>目前一些流行的浏览器（例如，IE 6.0）的默认设置就是使用 HTTP/1.1。</p><p><strong>持续连接的两种工作方式</strong></p><ul><li><strong>非流水线方式</strong>：客户在收到前一个响应后才能发出下一个请求。这比非持续连接的两倍 RTT 的开销节省了建立 TCP 连接所需的一个 RTT 时间。但服务器在发送完一个对象后，其 TCP 连接就处于空闲状态，浪费了服务器资源。</li><li><strong>流水线方式</strong>：客户在收到 HTTP 的响应报文之前就能够接着发送新的请求报文。一个接一个的请求报文到达服务器后，服务器就可连续发回响应报文。使用流水线方式时，客户访问所有的对象只需花费一个 RTT时间，使 TCP 连接中的空闲时间减少，提高了下载文档效率。</li></ul><hr><p><strong>代理服务器</strong></p><p>代理服务器(proxy server)又称为万维网<strong>高速缓存</strong>(Web cache)，它代表浏览器发出 HTTP 请求。</p><p>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中。</p><p>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去因特网访问该资源。</p><p><strong>使用高速缓存可减少访问因特网服务器的时延</strong></p><p><a href="/pic/network/6-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-10.png" class="lazyload"></a></p><p><strong>使用高速缓存的情况</strong></p><p><a href="/pic/network/6-11.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-11.png" class="lazyload"></a></p><ol><li>浏览器访问因特网的服务器时，要先与校园网的高速缓存建立 TCP 连接，并向高速缓存发出 HTTP 请求报文。</li><li>若高速缓存已经存放了所请求的对象，则将此对象放入 HTTP 响应报文中返回给浏览器。</li><li>否则，高速缓存就代表发出请求的用户浏览器，与因特网上的源点服务器建立 TCP 连接，并发送 HTTP 请求报文。</li><li>源点服务器将所请求的对象放在 HTTP 响应报文中返回给校园网的高速缓存。</li><li>高速缓存收到此对象后，先复制在其本地存储器中（为今后使用），然后再将该对象放在 HTTP 响应报文中，通过已建立的 TCP 连接，返回给请求该对象的浏览器。</li></ol><h4 id="433-http-的报文结构"><a class="markdownIt-Anchor" href="#433-http-的报文结构"></a> 4.3.3 HTTP 的报文结构</h4><p>HTTP 有两类报文：</p><ul><li><strong>请求报文</strong>：从客户向服务器发送请求报文。</li><li><strong>响应报文</strong>：从服务器到客户的回答。</li></ul><p>由于 HTTP 是面向正文的(text-oriented)，因此在报文中的每一个字段都是一些 ASCII 码串，因而每个字段的长度都是不确定的。</p><hr><p><strong>请求报文</strong></p><p><a href="/pic/network/6-12.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-12.png" class="lazyload"></a></p><p>报文由三个部分组成，即开始行、首部行和实体主体。在请求报文中，开始行就是请求行。</p><p><strong>方法</strong>：是面向对象技术中使用的专门名词。所谓“方法”就是<strong>对所请求的对象进行的操作</strong>，因此这些方法实际上也就是一些<strong>命令</strong>。因此，请求报文的类型是由它所采用的方法决定的。</p><table><thead><tr><th>方法（操作）</th><th>意义</th></tr></thead><tbody><tr><td>OPTION</td><td>请求一些选项的信息</td></tr><tr><td>GET</td><td>请求读取由 URL所标志的信息</td></tr><tr><td>HEAD</td><td>请求读取由 URL所标志的信息的首部</td></tr><tr><td>POST</td><td>给服务器添加信息（例如，注释）</td></tr><tr><td>PUT</td><td>在指明的 URL下存储一个文档</td></tr><tr><td>DELETE</td><td>删除指明的 URL所标志的资源</td></tr><tr><td>TRACE</td><td>用来进行环回测试的请求报文</td></tr><tr><td>CONNECT</td><td>用于代理服务器</td></tr></tbody></table><p><strong>URL</strong>：是所请求的资源的 URL。</p><p><strong>版本</strong>：是 HTTP 的版本。</p><p><strong>响应报文</strong></p><p><a href="/pic/network/6-13.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-13.png" class="lazyload"></a></p><p>响应报文的开始行是状态行。状态行包括三项内容，即 HTTP 的版本，状态码，以及解释状态码的简单短语。</p><p>状态码都是三位数字</p><ul><li>1xx 表示通知信息的，如请求收到了或正在进行处理。</li><li>2xx 表示成功，如接受或知道了。</li><li>3xx 表示重定向，表示要完成请求还必须采取进一步的行动。</li><li>4xx 表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx 表示服务器的差错，如服务器失效无法完成请求。</li></ul><h4 id="434-在服务器上存放用户的信息"><a class="markdownIt-Anchor" href="#434-在服务器上存放用户的信息"></a> 4.3.4 在服务器上存放用户的信息</h4><p>万维网站点使用 Cookie 来跟踪用户。</p><p>Cookie 表示在 HTTP 服务器和客户之间传递的状态信息。</p><p>使用 Cookie 的网站服务器为用户产生一个唯一的识别码。利用此识别码，网站就能够跟踪该用户在该网站的活动。</p><h3 id="44-万维网的文档"><a class="markdownIt-Anchor" href="#44-万维网的文档"></a> 4.4 万维网的文档</h3><h4 id="441-超文本标记语言-html"><a class="markdownIt-Anchor" href="#441-超文本标记语言-html"></a> 4.4.1 超文本标记语言 HTML</h4><p>超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。</p><p>HTML 定义了许多用于排版的命令（即标签）。</p><p>HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。</p><p><strong>HTML 文档</strong></p><ul><li>仅当 HTML 文档是以.html 或 .htm 为后缀时，浏览器才对此 文档的各种标签进行解释。</li><li>如 HTML 文档改换以 .txt 为其后缀，则 HTML 解释程序就不对标签进行解释，而浏览器只能看见原来的文本文件。</li><li>当浏览器从服务器读取 HTML 文档后，就按照 HTML 文档中的各种标签，根据浏览器所使用的显示器的尺寸和分辨率大小，重新进行排版并恢复出所读取的页面。</li></ul><p><strong>两种不同的链接</strong></p><ul><li><strong>远程链接</strong>：超链的终点是其他网点上的页面。</li><li><strong>本地链接</strong>：超链指向本计算机中的某个文件。</li></ul><h4 id="442-动态万维网文档"><a class="markdownIt-Anchor" href="#442-动态万维网文档"></a> 4.4.2 动态万维网文档</h4><p><strong>静态文档</strong>是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。</p><p><strong>动态文档</strong>是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。</p><p>动态文档和静态文档之间的主要差别体现在<strong>服务器</strong>一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。</p><p><strong>万维网服务器功能的扩充</strong></p><ol><li>应增加另一个应用程序，用来处理浏览器发来的数据，并创建动态文档。</li><li>应增加一个机制，用来使万维网服务器把浏览器发来的数据传送给这个应用程序，然后万维网服务器能够解释这个应用程序的输出，并向浏览器返回 HTML 文档。</li></ol><p><a href="/pic/network/6-14.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-14.png" class="lazyload"></a></p><p><strong>通用网关接口 CGI</strong></p><p>CGI 是一种标准，它定义了动态文档应如何创建，输入数据应如何提供给应用程序，以及输出结果应如何使用。</p><p>万维网服务器与 CGI 的通信遵循 CGI 标准。</p><ul><li>“通用”：CGI 标准所定义的规则对其他任何语言都是通用的。</li><li>“网关”：CGI 程序的作用像网关。</li><li>“接口”：有一些已定义好的变量和调用等可供其他 CGI 程序使用</li></ul><p><strong>CGI 程序</strong></p><p>CGI 程序的正式名字是 CGI 脚本(script)。</p><p>“<strong>脚本</strong>”指的是一个程序，它被另一个程序（解释程序）而不是计算机的处理机来解释或执行。</p><p>脚本运行起来要比一般的编译程序要慢，因为它的每一条指令先要被另一个程序来处理（这就要一些附加的指令），而不是直接被指令处理器来处理。</p><h4 id="443-活动万维网文档"><a class="markdownIt-Anchor" href="#443-活动万维网文档"></a> 4.4.3 活动万维网文档</h4><p>活动文档(active document)技术把所有的工作都转移给浏览器端。</p><p>每当浏览器请求一个活动文档时，服务器就返回一段程序副本在浏览器端运行。</p><p>活动文档程序可与用户直接交互，并可连续地改变屏幕的显示。</p><p>由于活动文档技术不需要服务器的连续更新传送，对网络带宽的要求也不会太高。</p><p><a href="/pic/network/6-15.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-15.png" class="lazyload"></a></p><h4 id="444-浏览器的结构"><a class="markdownIt-Anchor" href="#444-浏览器的结构"></a> 4.4.4 浏览器的结构</h4><p><a href="/pic/network/6-16.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-16.png" class="lazyload"></a></p><p><strong>浏览器的主要组成部分</strong></p><p>浏览器有一组客户、一组解释程序，以及管理这些客户和解释程序的控制程序。控制程序是其中的核心部件，它解释鼠标的点击和键盘的输入，并调用有关的组件来执行用户指定的操作。</p><p>例如，当用户用鼠标点击一个超链的起点时，控制程序就调用一个客户从所需文档所在的远地服务器上取回该文档，并调用解释程序向用户显示该文档。</p><p><strong>解释程序</strong></p><p>HTML 解释程序是必不可少的，而其他的解释程序则是可选的。 解释程序把 HTML 规格转换为适合用户显示硬件的命令来处理版面的细节。 许多浏览器还包含 FTP 客户程序，用来获取文件传送服务。一些浏览器也包含电子邮件客户程序，使浏览器能够发送和接收电子邮件。</p><p><strong>浏览器中的缓存</strong></p><p>浏览器将它取回的每一个页面副本都放入本地磁盘的缓存中。当用户用鼠标点击某个选项时，浏览器首先检查磁盘的缓存。若缓存中保存了该项，浏览器就直接从缓存中得到该项副本而不必从网络获取，这样就明显地改善浏览器的运行特性。</p><p>但缓存要占用磁盘大量的空间，而浏览器性能的改善只有在用户再次查看缓存中的页面时才有帮助。许多浏览器允许用户调整缓存策略。</p><h3 id="45-万维网的信息检索系统"><a class="markdownIt-Anchor" href="#45-万维网的信息检索系统"></a> 4.5 万维网的信息检索系统</h3><p>在万维网中用来进行搜索的程序叫做搜索引擎。</p><p><strong>全文检索搜索</strong></p><p>全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到因特网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。</p><p>用户在查询时只要输入关键词，就从已经建立的索引数据库上进行查询（并不是实时地在因特网上检索到的信息）。</p><p><strong>分类目录搜索</strong></p><p>分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。</p><p>分类目录搜索也叫做分类网站搜索。</p><p><strong>垂直搜索引擎</strong></p><p>针对某一特定领域、特定人群或某一特定需求提供搜索服务。垂直搜索也是提供关键字来进行搜索的，但被放到了一个行业知识的上下文中，返回的结果更倾向于信息、消息、条目等。</p><h2 id="5-电子邮件"><a class="markdownIt-Anchor" href="#5-电子邮件"></a> 5 电子邮件</h2><h3 id="51-概述"><a class="markdownIt-Anchor" href="#51-概述"></a> 5.1 概述</h3><p>电子邮件(e-mail)是因特网上使用得最多的和最受用户欢迎的一种应用。电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取。</p><p>电子邮件不仅使用方便，而且还具有传递迅速和费用低廉的优点。现在电子邮件不仅可传送文字信息，而且还可附上声音和图像。</p><p><strong>电子邮件的标准</strong></p><ul><li>发送邮件的协议：SMTP</li><li>读取邮件的协议：POP3 和 IMAP</li><li>MIME 在其邮件首部中说明了邮件的数据类型(如文本、声音、图像、视像等)，使用 MIME 可在邮件中同时传送多种类型的数据。</li></ul><p><strong>电子邮件的最主要的组成构件</strong></p><p><a href="/pic/network/6-17.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-17.png" class="lazyload"></a></p><p><strong>用户代理 UA (User Agent)</strong></p><ul><li>用户代理 UA 就是用户与电子邮件系统的接口，是电子邮件客户端软件。</li><li>用户代理的功能：撰写、显示、处理和通信。</li><li>邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。</li><li>邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。</li></ul><p>一个邮件服务器既可以作为客户，也可以作为服务器。例如，当邮件服务器 A 向另一个邮件服务器 B 发送邮件时，邮件服务器 A 就作为 SMTP 客户，而 B 是 SMTP 服务器；当邮件服务器 A 从另一个邮件服务器 B 接收邮件时，邮件服务器 A 就作为 SMTP 服务器，而 B 是 SMTP 客户。</p><p><strong>发送和接收电子邮件的重要步骤</strong></p><ol><li>发件人调用 PC 机中的用户代理撰写和编辑要发送的邮件。</li><li>发件人的用户代理把邮件用 SMTP 协议发给发送方邮件服务器，</li><li>SMTP 服务器把邮件临时存放在邮件缓存队列中，等待发送。</li><li>发送方邮件服务器的 SMTP 客户与接收方邮件服务器的 SMTP 服务器建立 TCP 连接，然后就把邮件缓存队列中的邮件依次发送出去。</li><li>运行在接收方邮件服务器中的SMTP服务器进 程收到邮件后，把邮件放入收件人的用户邮箱中，等待收件人进行读取。</li><li>收件人在打算收信时，就运行 PC 机中的用户代理，使用 POP3（或 IMAP）协议读取发送给自己的邮件。</li><li>请注意，POP3 服务器和 POP3 客户之间的通信是由 POP3 客户发起的。</li></ol><p><strong>电子邮件的组成</strong></p><p>电子邮件由<strong>信封</strong>(envelope)和<strong>内容</strong>(content)两部分组成。</p><p>电子邮件的传输程序根据邮件信封上的信息来传送邮件。用户在从自己的邮箱中读取邮件时才能见到邮件的内容。在邮件的信封上，最重要的就是收件人的地址。</p><p><strong>电子邮件地址的格式</strong></p><p>TCP/IP 体系的电子邮件系统规定电子邮件地址的格式如下：</p><pre class="highlight"><code class>收件人邮箱名@邮箱所在主机的域名</code></pre><p>邮箱所在的主机的域名在全世界必须是唯一的，用户名在该域名的范围内是唯一的。</p><h3 id="52-简单邮件传送协议-smtp"><a class="markdownIt-Anchor" href="#52-简单邮件传送协议-smtp"></a> 5.2 简单邮件传送协议 SMTP</h3><p>SMTP 所规定的就是在两个相互通信的 SMTP 进程之间应如何交换信息。</p><p>由于 SMTP 使用客户服务器方式，因此负责发送邮件的 SMTP 进程就是 SMTP 客户，而负责接收邮件的 SMTP 进程就是 SMTP 服务器。</p><p>SMTP 规定了 14 条命令和 21 种应答信息。每条命令用 4 个字母组成，而每一种应答信息一般只有一行信息，由一个 3 位数字的代码开始，后面附上（也可不附上）很简单的文字说明。</p><p><strong>SMTP 通信的三个阶段</strong></p><ol><li>连接建立：连接是在发送主机的 SMTP 客户和接收主机的 SMTP 服务器之间建立的。SMTP不使用中间的邮件服务器。</li><li>邮件传送</li><li>连接释放：邮件发送完毕后，SMTP 应释放 TCP 连接。</li></ol><h3 id="53-电子邮件的信息格式"><a class="markdownIt-Anchor" href="#53-电子邮件的信息格式"></a> 5.3 电子邮件的信息格式</h3><p>一个电子邮件分为<strong>信封</strong>和<strong>内容</strong>两大部分。</p><p>RFC 822 只规定了邮件内容中的首部(header)格式，而对邮件的主体(body)部分则让用户自由撰写。</p><p>用户写好首部后，邮件系统将自动地将信封所需的信息提取出来并写在信封上。所以用户不需要填写电子邮件信封上的信息。</p><p><strong>邮件内容的首部</strong></p><ul><li>“To:”后面填入一个或多个收件人的电子邮件地址。用户只需打开地址簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。</li><li>“Subject:”是邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。</li><li>抄送 “Cc:” 表示应给某某人发送一个邮件副本。</li><li>“From” 和 “Date” 表示发信人的电子邮件地址和发信日期。“Reply-To” 是对方回信所用的地址。</li></ul><h3 id="54-邮件读取协议-pop3-和-imap"><a class="markdownIt-Anchor" href="#54-邮件读取协议-pop3-和-imap"></a> 5.4 邮件读取协议 POP3 和 IMAP</h3><p>邮局协议 POP 是一个非常简单、但功能有限的邮件读取协议，现在使用的是它的第三个版本 POP3。</p><p>POP 也使用客户服务器的工作方式。在接收邮件的用户 PC 机中必须运行 POP 客户程序，而在用户所连接的 ISP 的邮件服务器中则运行 POP 服务器程序。</p><p><strong>IMAP 协议</strong></p><p>IMAP 也是按客户服务器方式工作，现在较新的是版本 4，即 IMAP4。</p><p>用户在自己的 PC 机上就可以操纵 ISP 的邮件服务器的邮箱，就像在本地操纵一样。因此 IMAP 是一个联机协议。当用户 PC 机上的 IMAP 客户程序打开 IMAP 服务器的邮箱时，用户就可看到邮件的首部。若用户需要打开某个邮件，则该邮件才传到用户的计算机上。</p><p><strong>IMAP 的特点</strong></p><p>IMAP最大的好处就是用户可以在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件。</p><p>IMAP 还允许收件人只读取邮件中的某一个部分。例如，收到了一个带有视像附件（此文件可能很大）的邮件。为了节省时间，可以先下载邮件的正文部分，待以后有时间再读取或下载这个很长的附件。</p><p>IMAP 的缺点是如果用户没有将邮件复制到自己的 PC 机上，则邮件一直是存放在 IMAP 服务器上。因此用户需要经常与 IMAP 服务器建立连接。</p><p><strong>注意事项</strong></p><p>不要将邮件读取协议 POP 或 IMAP 与邮件传送协议 SMTP 弄混。</p><p>发信人的用户代理向源邮件服务器发送邮件，以及源邮件服务器向目的邮件服务器发送邮件，都是使用 SMTP 协议。而 POP 协议或 IMAP 协议则是用户从目的邮件服务器上读取邮件所使用的协议。</p><h3 id="55-基于万维网的电子邮件"><a class="markdownIt-Anchor" href="#55-基于万维网的电子邮件"></a> 5.5 基于万维网的电子邮件</h3><p>电子邮件从 A 发送到网易邮件服务器是使用 HTTP 协议。</p><p>两个邮件服务器之间的传送使用 SMTP。</p><p>邮件从新浪邮件服务器传送到 B 是使用 HTTP 协议。</p><p><a href="/pic/network/6-18.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-18.png" class="lazyload"></a></p><h3 id="56-通用因特网邮件扩充-mime"><a class="markdownIt-Anchor" href="#56-通用因特网邮件扩充-mime"></a> 5.6 通用因特网邮件扩充 MIME</h3><p>SMTP 有以下缺点：</p><ul><li>SMTP 不能传送可执行文件或其他的二进制对象。</li><li>SMTP 限于传送 7 位的 ASCII 码。许多其他非英语国家的文字（如中文、俄文，甚至带重音符号的法文或德文）就无法传送。</li><li>SMTP 服务器会拒绝超过一定长度的邮件。</li><li>某些 SMTP 的实现并没有完全按照[RFC 821]的 SMTP 标准。</li></ul><p><strong>MIME 的特点</strong></p><p>MIME 并没有改动 SMTP 或取代它。MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。</p><p><strong>MIME 和 SMTP 的关系</strong></p><p><a href="/pic/network/6-19.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-19.png" class="lazyload"></a></p><p><strong>MIME 主要包括三个部分</strong></p><ol><li>5 个新的邮件首部字段，它们可包含在[RFC 822]首部中。这些字段提供了有关邮件主体的信息。</li><li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化。</li><li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变。</li></ol><p><strong>MIME 增加 5 个新的邮件首部</strong></p><ol><li>MIME-Version: 标志 MIME 的版本。现在的版本号是 1.0。若无此行，则为英文文本。</li><li>Content-Description: 这是可读字符串，说明此邮件是什么。和邮件的主题差不多。</li><li>Content-Id: 邮件的唯一标识符。</li><li>Content-Transfer-Encoding: 在传送时邮件的主体是如何编码的。</li><li>Content-Type: 说明邮件的性质。</li></ol><hr><p><strong>内容传送编码</strong></p><p>最简单的编码就是 7 位 ASCII 码，而每行不能超过 1000 个字符。MIME 对这种由 ASCII 码构成的邮件主体不进行任何转换。</p><p>另一种编码称为 quoted-printable，这种编码方法适用于当所传送的数据中只有少量的非 ASCII 码。</p><p>对于任意的二进制文件，可用 base64 编码。</p><p><strong>内容类型</strong></p><p>MIME着标准规定 Content-Type 说明必须含有两个标识符，即内容类型(type)和子类型(subtype)，中间用“/”分开。 MIME 标准定义了 7 个基本内容类型和 15 种子类型。</p><h2 id="6-动态主机配置协议-dhcp"><a class="markdownIt-Anchor" href="#6-动态主机配置协议-dhcp"></a> 6 动态主机配置协议 DHCP</h2><p>为了将软件协议做成通用的和便于移植，协议软件的编写者把协议软件参数化。这就使得在很多台计算机上使用同一个经过编译的二进制代码成为可能。</p><p>一台计算机和另一台计算机的区别，都可通过一些不同的参数来体现。在软件协议运行之前，必须给每一个参数赋值。</p><p><strong>协议配置</strong></p><p>在协议软件中给这些参数赋值的动作叫做协议配置。一个软件协议在使用之前必须是已正确配置的。具体的配置信息有哪些则取决于协议栈。</p><p>需要配置的项目：</p><ol><li>IP 地址</li><li>子网掩码</li><li>默认路由器的 IP 地址</li><li>域名服务器的 IP 地址</li></ol><p>这些信息通常存储在一个配置文件中，计算机在引导过程中可以对这个文件进行存取。</p><hr><p><strong>动态主机配置协议 DHCP</strong></p><p>提供了即插即用连网(plug-and-play networking)的机制。这种机制允许一台计算机加入新的网络和获取IP地址而不用手工参与。</p><p><strong>DHCP 使用客户服务器方式</strong></p><p>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送<strong>发现报文</strong>（DHCPDISCOVER），这时该主机就成为 DHCP 客户。</p><p>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</p><p>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池(address pool)中取一个地址分配给该计算机。DHCP 服务器的回答报文叫做<strong>提供报文</strong>（DHCPOFFER）。</p><p><strong>DHCP 中继代理(relay agent)</strong></p><p>并不是每个网络上都有 DHCP 服务器，这样会使 DHCP 服务器的数量太多。现在是每一个网络至少有一个 DHCP 中继代理，它配置了 DHCP 服务器的 IP 地址信息。</p><p>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机。</p><p><a href="/pic/network/6-20.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-20.png" class="lazyload"></a></p><hr><p><strong>租用期</strong></p><p>DHCP 服务器分配给 DHCP 客户的 IP 地址是临时的，因此 DHCP 客户只能在一段有限的时间内使用这个分配到的 IP 地址。DHCP 协议称这段时间为<strong>租用期</strong>。 租用期的数值应由 DHCP 服务器自己决定。</p><p>DHCP 客户也可在自己发送的报文中（例如，发现报文）提出对租用期的要求。</p><p><strong>DHCP 协议的工作过程</strong></p><p><a href="/pic/network/6-21.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-21.png" class="lazyload"></a></p><ol><li>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。</li><li>DHCP 客户从 UDP 端口 68 发送 DHCP 发现报文。</li><li>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到多个 DHCP 提供报文。</li><li>DHCP 客户从几个 DHCP 服务器中选择其中的一个，并向所选择的 DHCP 服务器发送 DHCP 请求报文。</li><li>被选择的 DHCP 服务器发送确认报文 DHCPACK，进入已绑定状态，并可开始使用得到的临时 IP 地址了。DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T<sub>1</sub> 和 T<sub>2</sub>，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</li><li>租用期过了一半（T<sub>1</sub> 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。</li><li>DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。</li><li>DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）。<br>若DHCP服务器不响应步骤6的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。</li><li>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</li></ol><h2 id="7-简单网络管理协议-snmp"><a class="markdownIt-Anchor" href="#7-简单网络管理协议-snmp"></a> 7 简单网络管理协议 SNMP</h2><h3 id="71-网络管理的基本概念"><a class="markdownIt-Anchor" href="#71-网络管理的基本概念"></a> 7.1 网络管理的基本概念</h3><p>网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。</p><p>网络管理并不是指对网络进行行政上的管理。</p><p><strong>网络管理的一般模型</strong></p><p><a href="/pic/network/6-22.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-22.png" class="lazyload"></a></p><p>网络管理模型中的主要构件</p><ul><li><strong>管理站</strong>也常称为<strong>网络运行中心 NOC</strong> (Network Operations Center)，是网络管理系统的核心。</li><li><strong>管理程序</strong>在运行时就成为<strong>管理进程</strong>。</li><li>管理站（硬件）或管理程序（软件）都可称为<strong>管理者</strong>(manager)。</li><li><strong>Manager</strong> 不是指人而是指机器或软件。</li><li><strong>网络管理员</strong>(administrator) 指的是人。大型网络往往实行多级管理，因而有多个管理者，而一个管理者一般只管理本地网络的设备。</li></ul><p><strong>被管对象</strong></p><p>网络的每一个被管设备中可能有多个被管对象。</p><p>被管设备有时可称为网络元素或网元。</p><p>在被管设备中也会有一些不能被管的对象。</p><p><strong>代理</strong></p><p>在每一个被管设备中都要运行一个程序以便和管理站中的管理程序进行通信。这些运行着的程序叫做<strong>网络管理代理程序</strong>，或简称为<strong>代理</strong>。</p><p>代理程序在管理程序的命令和控制下在被管设备上采取本地的行动。</p><p><strong>网络管理协议</strong></p><p>网络管理协议，简称为网管协议。需要注意的是，并不是网管协议本身来管理网络。网管协议就是管理程序和代理程序之间进行通信的规则。</p><p>网络管理员利用网管协议通过管理站对网络中的被管设备进行管理。</p><p><strong>客户服务器方式</strong></p><p>管理程序和代理程序按客户服务器方式工作。</p><p>管理程序运行 SNMP 客户程序，向某个代理程序发出请求（或命令），代理程序运行 SNMP 服务器程序，返回响应（或执行某个动作）。</p><p>在网管系统中往往是一个（或少数几个）客户程序与很多的服务器程序进行交互。</p><p><strong>网络管理的基本原理</strong>：若要管理某个对象，就必然会给该对象添加一些软件或硬件，但这种“添加”必须对原有对象的影响尽量小些。</p><hr><p><strong>SNMP 的指导思想</strong></p><ul><li>SNMP 最重要的指导思想就是要尽可能简单。</li><li>SNMP 的基本功能包括监视网络性能、检测分析网络差错和配置网络设备等。</li><li>在网络正常工作时，SNMP 可实现统计、配置、和测试等功能。当网络出故障时，可实现各种差错检测和恢复功能。</li><li>虽然 SNMP 是在 TCP/IP 基础上的网络管理协议，但也可扩展到其他类型的网络设备上。</li></ul><p><strong>SNMP 的管理站和委托代理</strong></p><p>整个系统必须有一个<strong>管理站</strong>。</p><p>管理进程和代理进程利用 SNMP 报文进行通信，而 SNMP 报文又使用 UDP 来传送。</p><p>若网络元素使用的不是 SNMP 而是另一种网络管理协议，SNMP 协议就无法控制该网络元素。这时可使用委托代理(proxy agent)。委托代理能提供如协议转换和过滤操作等功能对被管对象进行管理。</p><p>SNMP 的网络管理由三个部分组成</p><ul><li>SNMP 本身；</li><li>管理信息结构 SMI (Structure of Management Information)；</li><li>管理信息库 MIB (Management Information Base)；</li></ul><p><strong>SNMP</strong></p><p>SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象（变量）名及其状态（值）。SNMP 负责读取和改变这些数值。</p><p><strong>SMI</strong></p><p>SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。</p><p>这样做是为了确保网络管理数据的语法和语义的无二义性。但从 SMI 的名称并不能看出它的功能。</p><p>SMI 并不定义一个实体应管理的对象数目，也不定义被管对象名以及对象名及其值之间的关联。</p><p><strong>MIB</strong></p><p>MIB 在被管理的实体中创建了命名对象，并规定了其类型。</p><h3 id="72-管理信息结构-smi"><a class="markdownIt-Anchor" href="#72-管理信息结构-smi"></a> 7.2 管理信息结构 SMI</h3><p>SMI 的功能：</p><ol><li>被管对象应怎样命名；</li><li>用来存储被管对象的数据类型有哪些种；</li><li>在网络上传送的管理数据应如何编码。</li></ol><p><a href="/pic/network/6-23.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-23.png" class="lazyload"></a></p><p><strong>SMI 使用 ASN.1</strong></p><p>SMI 标准指明了所有的 MIB 变量必须使用抽象语法记法 1（ASN.1）来定义。SMI 既是 ASN.1 的子集，又是 ASN.1 的超集。 ASN.1 的记法很严格，它使得数据的含义不存在任何可能的二义性。SMI 把数据类型分为两大类：简单类型和结构化类型。</p><p><strong>基本编码规则 BER</strong></p><p>ISO 在制订 ASN.1 语言的同时也为它定义了一种标准的编码方案，即基本编码规则 BER。</p><p>BER 指明了每种数据类型中每个数据的值的表示。</p><p>发送端用 BER 编码，可将用 ASN.1 所表述的报文转换成唯一的比特序列。接收端用 BER 进行解码，得到该比特序列所表示的 ASN.1 报文。</p><p><strong>用 TLV 方法进行编码</strong></p><p>把各种数据元素表示为以下三个字段组成的八位位组序列：</p><ol><li>T 字段，即标识符八位位组(identifier octet)，用于<strong>标识标记</strong>。</li><li>L 字段，即长度用八位位组(length octet)，用于<strong>标识后面 V 字段的长度</strong>。</li><li>V 字段，即内容八位位组(content octet)，用于<strong>标识数据元素的值</strong>。</li></ol><p>TLV 中的 T 字段定义数据的类型</p><p><a href="/pic/network/6-24.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-24.png" class="lazyload"></a></p><p>TLV 中的 L 字段定义 V 字段的长度</p><p><a href="/pic/network/6-25.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-25.png" class="lazyload"></a></p><p>TLV 中的 V 字段定义数据的值</p><p>例如，INTEGER 15，其 T 字段是02， INTEGER 类型要用 4 字节编码。最后得出 TLV 编码为 02 04 00 00 00 0F。</p><p>又如 IPAddress 192.1.2.3，其 T 字段是 40，V 字段需要 4 字节表示，因此得出 IPAddress 192.1.2.3 的 TLV 编码是 40 04 C0 01 02 03。</p><h3 id="73-管理信息库-mib"><a class="markdownIt-Anchor" href="#73-管理信息库-mib"></a> 7.3 管理信息库 MIB</h3><p>被管对象必须维持可供管理程序读写的若干控制和状态信息。这些信息总称为<strong>管理信息库 MIB</strong> 。</p><p>管理程序使用 MIB 中这些信息的<strong>值</strong>对网络进行管理（如读取或重新设置这些值）。</p><h3 id="74-snmp-的协议数据单元和报文"><a class="markdownIt-Anchor" href="#74-snmp-的协议数据单元和报文"></a> 7.4 SNMP 的协议数据单元和报文</h3><p>SNMP的操作只有两种基本的管理功能，即：</p><ul><li>“读”操作，用 get 报文来检测各被管对象的状况；</li><li>“写”操作，用 set 报文来改变各被管对象的状况。</li></ul><p><strong>SNMP 的探询操作</strong></p><p>探询操作——SNMP 管理进程定时向被管理设备周期性地发送探询信息。</p><p>探询的好处是：</p><ul><li>可使系统相对简单。</li><li>能限制通过网络所产生的管理信息的通信量。</li></ul><p>但探询管理协议不够灵活，而且所能管理的设备数目不能太多。探询系统的开销也较大。如探询频繁而并未得到有用的报告，则通信线路和计算机的 CPU 周期就被浪费了。</p><p><strong>陷阱</strong></p><p>SNMP 不是完全的探询协议，它允许不经过询问就能发送某些信息。这种信息称为陷阱，表示它能够捕捉“事件”。这种陷阱信息的参数是受限制的。</p><p>当被管对象的代理检测到有事件发生时，就检查其门限值。代理只向管理进程报告达到某些门限值的事件（即<strong>过滤</strong>）。过滤的好处是：</p><ul><li>仅在严重事件发生时才发送陷阱；</li><li>陷阱信息很简单且所需字节数很少。</li></ul><p><strong>SNMP 是有效的网络管理协议</strong></p><p>使用探询（至少是周期性地）以维持对网络资源的实时监视，同时也采用陷阱机制报告特殊事件，使得 SNMP 成为一种有效的网络管理协议。</p><p><strong>SNMP 使用无连接的 UDP</strong></p><p>SNMP 使用无连接的 UDP，因此在网络上传送 SNMP 报文的开销较小。但 UDP 不保证可靠交付。</p><p>在运行代理程序的服务器端用熟知端口 161 来接收 get 或 set 报文和发送响应报文（与熟知端口通信的客户端使用临时端口）；运行管理程序的客户端则使用熟知端口 162 来接收来自各代理的 trap 报文。</p><p><strong>SNMP 的报文格式</strong></p><p><a href="/pic/network/6-26.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-26.png" class="lazyload"></a></p><h2 id="8-应用进程跨越网络的通信"><a class="markdownIt-Anchor" href="#8-应用进程跨越网络的通信"></a> 8 应用进程跨越网络的通信</h2><h3 id="81-系统调用和应用编程接口"><a class="markdownIt-Anchor" href="#81-系统调用和应用编程接口"></a> 8.1 系统调用和应用编程接口</h3><p>大多数操作系统使用<strong>系统调用</strong>(system call)的机制在应用程序和操作系统之间传递控制权。</p><p>对程序员来说，每一个系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控制权传递给了操作系统。</p><p><strong>多个应用进程使用系统调用的机制</strong></p><p><a href="/pic/network/6-27.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-27.png" class="lazyload"></a></p><p><strong>应用编程接口 API</strong></p><p>当某个应用进程启动系统调用时，控制权就从应用进程传递给了<strong>系统调用接口</strong>。此接口再将控制权传递给计算机的操作系统。操作系统将此调用转给某个内部过程，并执行所请求的操作。</p><p>内部过程一旦执行完毕，控制权就又通过系统调用接口返回给应用进程。系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口，即<strong>应用编程接口 API</strong>。</p><p><strong>应用进程通过套接字接入到网络</strong></p><p><a href="/pic/network/6-28.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-28.png" class="lazyload"></a></p><p><strong>套接字的作用</strong></p><p>当应用进程需要使用网络进行通信时就发出系统调用，请求操作系统为其创建“套接字”，以便把网络通信所需要的系统资源分配给该应用进程。</p><p>操作系统为这些资源的总和用一个叫做<strong>套接字描述符</strong>的号码来表示，并把此号码返回给应用进程。应用进程所进行的网络操作都必须使用这个号码。</p><p>通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该“号码”相关的所有资源。</p><p><a href="/pic/network/6-29.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-29.png" class="lazyload"></a></p><h3 id="82-几种常用的系统调用"><a class="markdownIt-Anchor" href="#82-几种常用的系统调用"></a> 8.2 几种常用的系统调用</h3><p>连接建立阶段：</p><p>当套接字被创建后，它的端口号和 IP 地址都是空的，因此应用进程要调用 bind（绑定）来指明套接字的本地地址。在服务器端调用 bind 时就是把熟知端口号和本地IP地址填写到已创建的套接字中。这就叫做把<strong>本地地址绑定到套接字</strong>。</p><p>服务器在调用 bind 后，还必须调用 listen（收听）把套接字设置为被动方式，以便随时接受客户的服务请求。UDP服务器由于只提供无连接服务，不使用 listen 系统调用。</p><p>服务器紧接着就调用 accept（接受），以便把远地客户进程发来的连接请求提取出来。系统调用 accept 的一个变量就是要指明从哪一个套接字发起的连接。</p><p><a href="/pic/network/6-30.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-30.png" class="lazyload"></a></p><p><strong>系统调用使用顺序的例子</strong></p><p><a href="/pic/network/6-31.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/6-31.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(六)：运输层</title>
      <link href="/2020/02/05/network-5/"/>
      <url>/2020/02/05/network-5/</url>
      
        <content type="html"><![CDATA[<h2 id="1-运输层协议概述"><a class="markdownIt-Anchor" href="#1-运输层协议概述"></a> 1 运输层协议概述</h2><h3 id="11-进程之间的通信"><a class="markdownIt-Anchor" href="#11-进程之间的通信"></a> 1.1 进程之间的通信</h3><p>从通信和信息处理的角度看，<strong>运输层向它上面的应用层提供通信服务</strong>，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p><p><a href="/pic/network/5-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-1.png" class="lazyload"></a></p><hr><p><strong>应用进程之间的通信</strong></p><p>两个主机进行通信实际上就是两个主机中的<strong>应用进程互相通信</strong>。</p><p>应用进程之间的通信又称为<strong>端到端的通信</strong>。</p><p>运输层的一个很重要的功能就是<strong>复用</strong>和<strong>分用</strong>。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</p><p>运输层提供应用进程间的<strong>逻辑通信</strong>：“逻辑通信”的意思是运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。</p><p><a href="/pic/network/5-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-2.png" class="lazyload"></a></p><hr><p><strong>运输层的主要功能</strong></p><ol><li>运输层为<strong>应用进程之间</strong>提供<strong>端到端</strong>的逻辑通信（但网络层是为<strong>主机之间</strong>提供逻辑通信）。</li><li>运输层还要对收到的报文进行差错检测。</li><li>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。</li></ol><p><strong>两种不同的运输协议</strong></p><p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p><ul><li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</li><li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。</li></ul><h3 id="12-运输层的两个主要协议"><a class="markdownIt-Anchor" href="#12-运输层的两个主要协议"></a> 1.2 运输层的两个主要协议</h3><p>TCP/IP 的运输层有两个不同的协议：</p><ol><li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)</li><li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol)</li></ol><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元 TPDU</strong> (Transport Protocol Data Unit)。</p><ol><li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>；</li><li>UDP 传送的数据单位协议是 <strong>UDP 报文或用户数据报</strong>；</li></ol><hr><p><strong>TCP 与 UDP 的主要区别</strong></p><ul><li>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</li><li>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</li><li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</li><li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</li></ul><h3 id="13-运输层的端口"><a class="markdownIt-Anchor" href="#13-运输层的端口"></a> 1.3 运输层的端口</h3><p>运行在计算机中的进程是用<strong>进程标识符</strong>来标志的。</p><p>运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。</p><p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就<strong>必须用统一的方法</strong>对 TCP/IP 体系的应用进程进行标志。</p><hr><p><strong>需要解决的问题</strong></p><ol><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li><li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li><li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li></ol><p><strong>端口号</strong></p><p>解决这个问题的方法就是在运输层使用协议端口号，或通常简称为端口(port)。</p><p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p><p><strong>软件端口与硬件端口</strong></p><ul><li>在协议栈层间的抽象的协议端口是软件端口。</li><li>路由器或交换机上的端口是硬件端口。</li></ul><p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。</p><hr><p><strong>TCP 的端口</strong></p><p>端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</p><p><strong>三类端口</strong></p><ol><li>熟知端口：数值一般为 0~1023。</li><li>登记端口号：数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li><li>客户端口号或短暂端口号：数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ol><h2 id="2-用户数据报协议-udp"><a class="markdownIt-Anchor" href="#2-用户数据报协议-udp"></a> 2 用户数据报协议 UDP</h2><h3 id="21-udp-概述"><a class="markdownIt-Anchor" href="#21-udp-概述"></a> 2.1 UDP 概述</h3><p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即<strong>端口</strong>的功能和<strong>差错检测</strong>的功能。</p><p>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p><p><strong>UDP 的主要特点</strong></p><ul><li>UDP 是无连接的，即发送数据之前不需要建立连接。</li><li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li><li>UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li><li>UDP 的首部开销小，只有 8 个字节。</li></ul><p><strong>面向报文的 UDP</strong></p><ul><li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li><li>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</li><li>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</li><li>应用程序必须选择合适大小的报文。</li></ul><p><a href="/pic/network/5-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-3.png" class="lazyload"></a></p><h3 id="22-udp-的首部格式"><a class="markdownIt-Anchor" href="#22-udp-的首部格式"></a> 2.2 UDP 的首部格式</h3><p><a href="/pic/network/5-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-4.png" class="lazyload"></a></p><p>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。</p><p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。<strong>伪首部仅仅是为了计算检验和</strong>。</p><p><a href="/pic/network/5-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-5.png" class="lazyload"></a></p><h2 id="3-传输控制协议-tcp-概述"><a class="markdownIt-Anchor" href="#3-传输控制协议-tcp-概述"></a> 3 传输控制协议 TCP 概述</h2><h3 id="31-tcp-最主要的特点"><a class="markdownIt-Anchor" href="#31-tcp-最主要的特点"></a> 3.1 TCP 最主要的特点</h3><p>TCP 协议的主要特点：</p><ul><li>TCP 是<strong>面向连接</strong>的运输层协议。</li><li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）。</li><li>TCP 提供可靠交付的服务。</li><li>TCP 提供全双工通信。</li><li>面向字节流。</li></ul><p><a href="/pic/network/5-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-6.png" class="lazyload"></a></p><p><strong>注意事项</strong>：</p><ul><li>TCP 连接是一条虚连接而不是一条真正的物理连接。</li><li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。</li><li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li><li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul><h3 id="32-tcp-的连接"><a class="markdownIt-Anchor" href="#32-tcp-的连接"></a> 3.2 TCP 的连接</h3><ul><li>TCP 把连接作为最基本的抽象。</li><li>每一条 TCP 连接有两个端点。</li><li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字</strong>(socket)或插口。</li><li>端口号拼接到 IP 地址即构成了套接字。</li></ul><pre class="highlight"><code class>套接字 socket = (IP地址: 端口号)</code></pre><p>每一条 <strong>TCP</strong> 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：</p><pre class="highlight"><code class>TCP连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}     </code></pre><h2 id="4-可靠传输的工作原理"><a class="markdownIt-Anchor" href="#4-可靠传输的工作原理"></a> 4 可靠传输的工作原理</h2><h3 id="41-停止等待协议"><a class="markdownIt-Anchor" href="#41-停止等待协议"></a> 4.1 停止等待协议</h3><p><a href="/pic/network/5-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-7.png" class="lazyload"></a></p><ul><li>在发送完一个分组后，必须暂时保留已发送的分组的副本。</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ul><p><a href="/pic/network/5-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-8.png" class="lazyload"></a></p><p><strong>可靠通信的实现</strong></p><p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p><p>这种可靠传输协议常称为<strong>自动重传请求ARQ</strong> (Automatic Repeat reQuest)。</p><p>ARQ 表明重传的请求是<strong>自动</strong>进行的。接收方不需要请求发送方重传某个出错的分组 。</p><hr><p><strong>信道利用率</strong></p><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p><a href="/pic/network/5-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-9.png" class="lazyload"></a></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">U=\frac{T_{D}}{T_{D}+RTT+T_{A}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>流水线传输</strong></p><p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。</p><p>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。</p><p><a href="/pic/network/5-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-10.png" class="lazyload"></a></p><h3 id="42-连续-arq-协议"><a class="markdownIt-Anchor" href="#42-连续-arq-协议"></a> 4.2 连续 ARQ 协议</h3><p><a href="/pic/network/5-11.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-11.png" class="lazyload"></a></p><p><strong>累积确认</strong></p><p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p><p>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p><p><strong>Go-back-N（回退 N）</strong></p><p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</p><p>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 <em>N</em> 个分组。</p><p>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p><hr><p><strong>TCP 可靠通信的具体实现</strong></p><ul><li>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。</li><li>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</li><li>TCP 两端的四个窗口经常处于动态变化之中。</li><li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。</li></ul><h2 id="5-tcp-报文段的首部格式"><a class="markdownIt-Anchor" href="#5-tcp-报文段的首部格式"></a> 5 TCP 报文段的首部格式</h2><p><a href="/pic/network/5-12.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-12.png" class="lazyload"></a></p><ul><li><strong>源端口和目的端口字段</strong>：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li><strong>序号字段</strong>：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li><strong>确认号字段</strong>：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li><strong>数据偏移</strong>（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li><li><strong>保留字段</strong>：占 6 位，保留为今后使用，但目前应置为 0。</li><li><strong>紧急 URG</strong>：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li><li><strong>确认 ACK</strong>：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</li><li><strong>推送 PSH</strong>：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li><li><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li><li><strong>同步 SYN</strong>：同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li><li><strong>终止 FIN</strong>：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li><li><strong>窗口字段</strong>：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li><li><strong>检验和</strong>：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li><strong>紧急指针字段</strong>：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li><li><strong>选项字段</strong>：长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS</strong>。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<br>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</li><li><strong>填充字段</strong>：这是为了使整个首部长度是 4 字节的整数倍。</li></ul><h2 id="6-tcp-可靠传输的实现"><a class="markdownIt-Anchor" href="#6-tcp-可靠传输的实现"></a> 6 TCP 可靠传输的实现</h2><h3 id="61-以字节为单位的滑动窗口"><a class="markdownIt-Anchor" href="#61-以字节为单位的滑动窗口"></a> 6.1 以字节为单位的滑动窗口</h3><p>根据 B 给出的窗口值 A 构造出自己的发送窗口。</p><p><a href="/pic/network/5-13.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-13.png" class="lazyload"></a></p><p><a href="/pic/network/5-14.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-14.png" class="lazyload"></a></p><p><a href="/pic/network/5-15.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-15.png" class="lazyload"></a></p><p><a href="/pic/network/5-16.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-16.png" class="lazyload"></a></p><hr><p><strong>发送缓存和接收缓存</strong></p><p><a href="/pic/network/5-17.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-17.png" class="lazyload"></a></p><p>发送缓存与接收缓存的作用：</p><ul><li>发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方 TCP 准备发送的数据；</li><li>TCP 已发送出但尚未收到确认的数据。</li></ul></li><li>接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据；</li><li>不按序到达的数据。</li></ul></li></ul><p><strong>需要注意的是</strong>：</p><ul><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li></ul><h3 id="62-超时重传时间的选择"><a class="markdownIt-Anchor" href="#62-超时重传时间的选择"></a> 6.2 超时重传时间的选择</h3><p>重传机制是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</p><p><strong>往返时延的方差很大</strong></p><p>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。</p><p><a href="/pic/network/5-18.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-18.png" class="lazyload"></a></p><hr><p><strong>加权平均往返时间</strong></p><p>TCP 保留了 RTT 的一个加权平均往返时间 RTT<sub>S</sub>（这又称为平滑的往返时间）。</p><p>第一次测量到 RTT 样本时，RTT<sub>S</sub> 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的RTT_{s}=(1-\alpha )\times (旧的RTT_{s})+\alpha \times (新的RTT样本)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose">)</span></span></span></span></span></p><p>上式中，0 ≤ a &lt; 1。若 a 很接近于零，表示 RTT 值更新较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。</p><p>RFC 2988 推荐的 a 值为 1/8，即 0.125。</p><hr><p><strong>超时重传时间 RTO</strong></p><p>RTO 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub>。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mn>4</mn><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTO = RTT_{S}+4\times RTT_{D}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>RTT<sub>D</sub> 是 RTT 的偏差的加权平均值。</p><p>RFC 2988 建议这样计算 RTT<sub>D</sub>。第一次测量时，RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mo>×</mo><mrow><mo fence="true">∣</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>−</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">新的 RTT_{D} = (1 - \beta ) \times  (旧的RTT_{D}) + \beta  \times  \left | RTT_{S} - 新的 RTT 样本   \right |</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span></span></p><p>β 是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p><hr><p><strong>往返时间的测量相当复杂</strong></p><p><a href="/pic/network/5-19.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-19.png" class="lazyload"></a></p><p>TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。</p><p>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？</p><p><strong>Karn 算法</strong></p><p>在计算平均往返时间 RTT 时，<strong>只要报文段重传了</strong>，就不采用其往返时间样本。</p><p>这样得出的加权平均平均往返时间 RTT<sub>S</sub> 和超时重传时间 RTO 就较准确。</p><p><strong>修正的 Karn 算法</strong></p><p>报文段每重传一次，就把 RTO 增大一些：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>γ</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>O</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的 RTO = \gamma  \times  (旧的 RTO)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mclose">)</span></span></span></span></span></p><p>系数 γ 的典型值是 2 。</p><p>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。实践证明，这种策略较为合理。</p><h3 id="63-选择确认-sack"><a class="markdownIt-Anchor" href="#63-选择确认-sack"></a> 6.3 选择确认 SACK</h3><p>接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p><p><a href="/pic/network/5-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-2.png" class="lazyload"></a></p><ul><li>和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。图中用四个指针标记这些边界。</li><li>第一个字节块的左边界 L<sub>1</sub> = 1501，但右边界 R<sub>1</sub> = 3001。</li><li>左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。</li><li>第二个字节块的左边界 L<sub>2</sub> = 3501，而右边界 R<sub>2</sub> = 4501。</li></ul><p><strong>RFC 2018 的规定</strong></p><ul><li>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</li><li>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</li><li>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</li></ul><h2 id="7-tcp-的流量控制"><a class="markdownIt-Anchor" href="#7-tcp-的流量控制"></a> 7 TCP 的流量控制</h2><h3 id="71-利用滑动窗口实现流量控制"><a class="markdownIt-Anchor" href="#71-利用滑动窗口实现流量控制"></a> 7.1 利用滑动窗口实现流量控制</h3><p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</p><p><strong>流量控制</strong>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。</p><p>流量控制举例：</p><p><a href="/pic/network/5-21.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-21.png" class="lazyload"></a></p><hr><p><strong>持续计时器</strong></p><ul><li>TCP 为每一个连接设有一个持续计时器。</li><li>只要 TCP 连接的一方收到对方的<strong>零窗口</strong>通知，就启动持续计时器。</li><li>若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</li><li>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</li><li>若窗口不是零，则死锁的僵局就可以打破了。</li></ul><h3 id="72-必须考虑传输效率"><a class="markdownIt-Anchor" href="#72-必须考虑传输效率"></a> 7.2 必须考虑传输效率</h3><p>可以用不同的机制来控制 TCP 报文段的发送时机:</p><ol><li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。</li><li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li></ol><h2 id="8-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#8-tcp的拥塞控制"></a> 8 TCP的拥塞控制</h2><h3 id="81-拥塞控制的原理"><a class="markdownIt-Anchor" href="#81-拥塞控制的原理"></a> 8.1 拥塞控制的原理</h3><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生<strong>拥塞</strong>。</p><p>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源。</p><p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p><p><strong>拥塞控制与流量控制的关系</strong></p><p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p><p>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p><p>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。</p><p>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><strong>拥塞控制所起的作用</strong></p><p><a href="/pic/network/5-22.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-22.png" class="lazyload"></a></p><p><strong>拥塞控制的原理</strong></p><p>拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。</p><p>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。</p><p>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。</p><hr><p><strong>开环控制和闭环控制</strong></p><p><strong>开环控制</strong>方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</p><p><strong>闭环控制</strong>是基于反馈环路的概念。属于闭环控制的有以下几种措施：</p><ul><li>监测网络系统以便检测到拥塞在何时、何处发生。</li><li>将拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ul><h3 id="82-拥塞控制方法"><a class="markdownIt-Anchor" href="#82-拥塞控制方法"></a> 8.2 拥塞控制方法</h3><h4 id="821-慢开始和拥塞避免"><a class="markdownIt-Anchor" href="#821-慢开始和拥塞避免"></a> 8.2.1 慢开始和拥塞避免</h4><p>发送方维持一个叫做拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p><strong>慢开始算法的原理</strong></p><ol><li>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</li><li>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。</li><li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li></ol><p><a href="/pic/network/5-23.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-23.png" class="lazyload"></a></p><p><strong>传输轮次</strong></p><ul><li>使用慢开始算法后，每经过一个<strong>传输轮次</strong>，拥塞窗口 cwnd 就加倍。</li><li>一个传输轮次所经历的时间其实就是往返时间 RTT。</li><li>“<strong>传输轮次</strong>”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</li><li>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</li></ul><p><strong>设置慢开始门限状态变量 ssthresh</strong></p><p>慢开始门限 ssthresh 的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul><p><strong>拥塞避免算法</strong>的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p><p><strong>当网络出现拥塞时</strong></p><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。</p><p>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</p><p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><p>慢开始和拥塞避免算法的实现举例</p><p><a href="/pic/network/5-24.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-24.png" class="lazyload"></a></p><p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p><p>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。</p><ol><li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M<sub>0</sub>。</li><li>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M<sub>1</sub> 和 M<sub>2</sub> 两个报文段。</li><li>接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。</li><li>发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。</li><li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li><li>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。</li><li>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。</li><li>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。</li></ol><p><strong>乘法减小</strong></p><p>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</p><p>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。</p><p><strong>加法增大</strong></p><p>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p><p><strong>必须强调指出</strong></p><ul><li>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li><li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li></ul><h4 id="822-快重传和快恢复"><a class="markdownIt-Anchor" href="#822-快重传和快恢复"></a> 8.2.2 快重传和快恢复</h4><p><strong>快重传算法</strong></p><ol><li>首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。</li><li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。</li><li>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</li></ol><p><a href="/pic/network/5-25.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-25.png" class="lazyload"></a></p><p><strong>快恢复算法</strong></p><ol><li>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。</li><li>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li></ol><p><a href="/pic/network/5-26.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-26.png" class="lazyload"></a></p><p><strong>发送窗口的上限值</strong></p><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p><pre class="highlight"><code class>发送窗口的上限值 = Min[rwnd, cwnd]                 </code></pre><ul><li>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。</li><li>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</li></ul><h3 id="83-随机早期检测-red"><a class="markdownIt-Anchor" href="#83-随机早期检测-red"></a> 8.3 随机早期检测 RED</h3><p>RED 将路由器的到达队列划分成为三个区域。</p><p><a href="/pic/network/5-27.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-27.png" class="lazyload"></a></p><ul><li>使路由器的队列维持两个参数，即队列长度最小门限 TH<sub>min</sub> 和最大门限 TH<sub>max</sub>。</li><li>RED 对每一个到达的数据报都先计算平均队列长度 <em>L</em><sub>AV</sub>。</li><li>若平均队列长度小于最小门限 TH<sub>min</sub>，则将新到达的数据报放入队列进行排队。</li><li>若平均队列长度超过最大门限 TH<sub>max</sub>，则将新到达的数据报丢弃。</li><li>若平均队列长度在最小门限 TH<sub>min</sub> 和最大门限 TH<sub>max</sub> 之间，则按照某一概率 <em>p</em> 将新到达的数据报丢弃。</li></ul><p><strong>丢弃概率 <em>p</em> 与 TH<sub>min</sub> 和 TH<sub>max</sub> 的关系</strong></p><ul><li>当 <em>L</em><sub>AV</sub> &lt; TH<sub>min</sub> 时，丢弃概率 <em>p</em> = 0。</li><li>当 <em>L</em><sub>AV</sub> &gt;TH<sub>max</sub> 时，丢弃概率 <em>p</em> = 1。</li><li>当 TH<sub>min</sub> &lt; <em>L</em><sub>AV</sub> &lt; TH<sub>max</sub>时，  0 &lt; <em>p</em> &lt; 1 。例如，按线性规律变化，从 0 变到 <em>p</em><sub>max</sub>。</li></ul><p><a href="/pic/network/5-28.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-28.png" class="lazyload"></a></p><h2 id="9-tcp-的运输连接管理"><a class="markdownIt-Anchor" href="#9-tcp-的运输连接管理"></a> 9 TCP 的运输连接管理</h2><p>运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p><p>连接建立过程中要解决以下三个问题：</p><ol><li>要使每一方能够确知对方的存在；</li><li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）；</li><li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配；</li></ol><p><strong>客户服务器方式</strong></p><p>TCP 连接的建立都是采用客户服务器方式。</p><p>主动发起连接建立的应用进程叫做<strong>客户</strong>(client)。</p><p>被动等待连接建立的应用进程叫做<strong>服务器</strong>(server)。</p><h3 id="91-tcp-的连接建立"><a class="markdownIt-Anchor" href="#91-tcp-的连接建立"></a> 9.1 TCP 的连接建立</h3><p>用三次握手建立 TCP 连接。</p><p><a href="/pic/network/5-29.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-29.png" class="lazyload"></a></p><ol><li>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</li><li>B 的 TCP 收到连接请求报文段后，如同意，则发回确认；B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</li><li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1；A 的 TCP 通知上层应用进程，连接已经建立。</li><li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li></ol><h3 id="92-tcp-的连接释放"><a class="markdownIt-Anchor" href="#92-tcp-的连接释放"></a> 9.2 TCP 的连接释放</h3><p><a href="/pic/network/5-30.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-30.png" class="lazyload"></a></p><ol><li>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</li><li>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</li><li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。</li><li>A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。</li><li>TCP 连接必须经过时间 2MSL 后才真正释放掉。</li></ol><p><strong>A 必须等待 2MSL 的时间</strong></p><ol><li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</li><li>防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li></ol><h3 id="93-tcp-的有限状态机"><a class="markdownIt-Anchor" href="#93-tcp-的有限状态机"></a> 9.3 TCP 的有限状态机</h3><p>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</p><p>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</p><p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p><p>图中有三种不同的箭头。</p><ul><li>粗实线箭头表示对客户进程的正常变迁。</li><li>粗虚线箭头表示对服务器进程的正常变迁。</li><li>另一种细线箭头表示异常变迁。</li></ul><p><a href="/pic/network/5-31.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/5-31.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(五)：网络层(二)</title>
      <link href="/2020/02/03/network-4-2/"/>
      <url>/2020/02/03/network-4-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网际控制报文协议-icmp"><a class="markdownIt-Anchor" href="#1-网际控制报文协议-icmp"></a> 1 网际控制报文协议 ICMP</h2><p>为了提高 IP 数据报交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 不是高层协议，而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。</p><p><a href="/pic/network/4-24.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-24.png" class="lazyload"></a></p><h3 id="11-icmp-报文的种类"><a class="markdownIt-Anchor" href="#11-icmp-报文的种类"></a> 1.1 ICMP 报文的种类</h3><p>ICMP 报文的种类有两种，即 <strong>ICMP 差错报告报文</strong>和 <strong>ICMP 询问报文</strong>。</p><p>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。</p><p><strong>ICMP 差错报告报文种类</strong>：</p><ol><li>终点不可达</li><li>源点抑制</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）</li></ol><p><strong>ICMP 差错报告报文的数据字段的内容</strong></p><p><a href="/pic/network/4-25.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-25.png" class="lazyload"></a></p><p>不应发送 ICMP 差错报告报文的几种情况：</p><ol><li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。</li><li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。</li><li>对具有多播地址的数据报都不发送 ICMP 差错报告报文。</li><li>对具有特殊地址（如127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</li></ol><hr><p><strong>ICMP 询问报文种类</strong></p><ol><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ol><h3 id="12-icmp的应用举例"><a class="markdownIt-Anchor" href="#12-icmp的应用举例"></a> 1.2 ICMP的应用举例</h3><p><strong>PING 命令</strong></p><ul><li>PING 用来测试两个主机之间的连通性。</li><li>PING 使用了 <strong>ICMP 回送请求与回送回答报文</strong>。</li><li>PING 是<strong>应用层直接使用网络层 ICMP</strong> 的例子，它没有通过运输层的 TCP 或UDP。</li></ul><p><strong>Traceroute 命令</strong></p><ul><li>traceroute 命令利用ICMP 协议定位您的计算机和目标计算机之间的所有路由器。</li><li>TTL 值可以反映数据包经过的路由器或网关的数量，通过操纵独立ICMP 呼叫报文的TTL 值和观察该报文被抛弃的返回信息，traceroute命令能够遍历到数据包传输路径上的所有路由器。</li><li>基于 UDP 实现和基于 ICMP 实现。</li></ul><h2 id="2-因特网的路由选择协议"><a class="markdownIt-Anchor" href="#2-因特网的路由选择协议"></a> 2 因特网的路由选择协议</h2><h3 id="21-路由选择协议的基本概念"><a class="markdownIt-Anchor" href="#21-路由选择协议的基本概念"></a> 2.1 路由选择协议的基本概念</h3><p><strong>最佳路由</strong></p><p>不存在一种绝对的最佳路由算法。所谓“最佳”只能是相对于某一种特定要求下得出的较为合理的选择而已。实际的路由选择算法，应尽可能接近于理想的算法。路由选择是个非常复杂的问题，它是网络中的所有结点共同协调工作的结果。路由选择的环境往往是不断变化的，而这种变化有时无法事先知道。</p><hr><p>从路由算法的<strong>自适应性</strong>考虑</p><ul><li><strong>静态路由选择策略</strong>：即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。</li><li><strong>动态路由选择策略</strong>：即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</li></ul><hr><p><strong>分层次的路由选择协议</strong></p><p>因特网采用分层次的路由选择协议。</p><p>因特网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使因特网的通信链路饱和。</p><p>许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到因特网上。</p><hr><p><strong>自治系统 AS</strong> (Autonomous System)</p><p>定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</p><p>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但重要的是一个 AS 对其他 AS 表现出的是一个<strong>单一的</strong>和<strong>一致的路由选择策略</strong>。</p><hr><p><strong>因特网有两大类路由选择协议</strong></p><p><strong>内部网关协议 IGP</strong>：即在一个自治系统内部使用的路由选择协议。目前这类路由选择协议使用得最多，如 <strong>RIP</strong> 和 <strong>OSPF</strong> 协议。</p><p><strong>外部网关协议 EGP</strong>：若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。在外部网关协议中目前使用最多的是 <strong>BGP-4</strong>。</p><p><a href="/pic/network/4-26.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-26.png" class="lazyload"></a></p><hr><h3 id="22-内部网关协议-rip"><a class="markdownIt-Anchor" href="#22-内部网关协议-rip"></a> 2.2 内部网关协议 RIP</h3><p><strong>工作原理</strong></p><p>路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。</p><p>RIP 是一种分布式的基于<strong>距离向量</strong>的路由选择协议。</p><p>RIP 协议要求网络中的每一个路由器都要维护<strong>从它自己到其他每一个目的网络的距离记录</strong>。</p><hr><p>“<strong>距离</strong>”的定义</p><ul><li>从一路由器到直接连接的网络的距离定义为 1；</li><li>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加 1；</li><li>RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1；</li><li>这里的“距离”实际上指的是“最短距离”；</li><li>RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</li><li>RIP 允许一条路径最多只能包含 15 个路由器。</li><li>“距离”的最大值为16 时即相当于不可达。可见 RIP 只适用于小型互联网。</li><li>RIP 不能在两个网络之间同时使用多条路由。RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速(低时延)但路由器较多的路由。</li></ul><hr><p><strong>RIP 协议的三个要点</strong></p><ol><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li></ol><hr><p><strong>路由表的建立</strong></p><ol><li>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为1）。</li><li>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。</li><li>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。</li><li>RIP 协议的收敛过程较快，即在自治系统中所有的结点都得到正确的路由选择信息的过程。</li></ol><p><strong>路由器之间交换信息</strong></p><p>RIP协议让互联网中的所有路由器都和自己的相邻路由器不断交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）。</p><p>虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。</p><hr><p><strong>距离向量算法</strong></p><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目：把“下一跳”字段中的地址都改为 X，并把所有的“距离”字段的值加 1。</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ol><li>若项目中的目的网络不在路由表中，则把该项目加到路由表中。</li><li>否则若下一跳字段给出的路由器地址是同样的，则把收到的项 目 替换原路由表中的项目。</li><li>否则若收到项目中的距离小于路由表中的距离，则进行更新，</li><li>否则什么也不做。</li></ol></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为16（距离为16表示不可达）。</li><li>返回。</li></ol><hr><p><strong>RIP2 协议的报文格式</strong></p><p><a href="/pic/network/4-27.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-27.png" class="lazyload"></a></p><p>RIP2 的报文由首部和路由部分组成。</p><ul><li>RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。</li><li><strong>地址族标识符</strong>（又称为地址类别）字段用来标志所使用的地址协议。</li><li><strong>路由标记</strong>填入自治系统的号码，这是考虑使RIP 有可能收到本自治系统以外的路由选择信息。</li><li>再后面指出某个<strong>网络地址</strong>、该网络的<strong>子网掩码</strong>、<strong>下一跳路由器地址</strong>以及<strong>到此网络的距离</strong>。</li></ul><hr><p><strong>RIP 协议的优缺点</strong></p><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器（     好消息传播得快，而坏消息传播得慢）。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><h3 id="23-内部网关协议-ospf"><a class="markdownIt-Anchor" href="#23-内部网关协议-ospf"></a> 2.3 内部网关协议 OSPF</h3><p><strong>OSPF 协议的基本特点</strong></p><ul><li>“开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的；</li><li>“最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF；</li><li>OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”；</li><li>是分布式的链路状态协议；</li></ul><hr><p><strong>三个要点</strong></p><ol><li><p>向本自治系统中<strong>所有路由器</strong>发送信息，这里使用的方法是<strong>洪泛法</strong>。</p></li><li><p>发送的信息就是与本路由器<strong>相邻的所有路由器的链路状态</strong>，但这只是路由器所知道的<strong>部分信息</strong>。</p><p>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。</p></li><li><p>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p></li></ol><hr><p><strong>链路状态数据库</strong></p><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。</p><p>这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的同步）。</p><p>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><hr><p><strong>OSPF 的区域</strong></p><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作<strong>区域</strong>。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。</p><p>OSPF 划分为两种不同的区域</p><p><a href="/pic/network/4-28.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-28.png" class="lazyload"></a></p><p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。</p><p>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。</p><p>OSPF 使用层次结构的区域划分。在上层的区域叫作<strong>主干区域</strong>。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。</p><hr><p><strong>OSPF 直接用 IP 数据报传送</strong></p><p>OSPF 不用 UDP 而是直接用 IP 数据报传送。</p><p>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</p><p>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><hr><p><strong>OSPF 的其他特点</strong></p><ul><li>OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，OSPF 对于不同类型的业务可计算出不同的路由。</li><li>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫作<strong>多路径间的负载平衡</strong>。</li><li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能。</li><li>支持可变长度的子网划分和无分类编址 CIDR。</li><li>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。</li></ul><p><a href="/pic/network/4-29.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-29.png" class="lazyload"></a></p><hr><p><strong>OSPF 的分组类型</strong></p><ol><li>问候(Hello)分组。</li><li>数据库描述(Database Description)分组。</li><li>链路状态请求(Link State Request)分组。</li><li>链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态。</li><li>链路状态确认(Link State Acknowledgment)分组。</li></ol><p><a href="/pic/network/4-30.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-30.png" class="lazyload"></a></p><hr><p><strong>OSPF 的其他特点</strong></p><ul><li>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。</li><li>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。</li><li>OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms。</li></ul><h3 id="24-外部网关协议-bgp"><a class="markdownIt-Anchor" href="#24-外部网关协议-bgp"></a> 2.4 外部网关协议 BGP</h3><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。</p><p><strong>BGP 使用的环境不同</strong></p><p>因特网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。比较合理的做法是在 AS 之间交换“可达性”信息。</p><p>自治系统之间的路由选择必须考虑有关策略。因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且<strong>比较好的路由</strong>（不能兜圈子），而<strong>并非要寻找一条最佳路由</strong>。</p><hr><p><strong>BGP 发言人</strong></p><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“ BGP 发言人” 。</p><p>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。</p><hr><p><strong>BGP 交换路由信息</strong></p><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话(session)，利用 BGP 会话交换路由信息。</p><p>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。</p><p>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p><hr><p><a href="/pic/network/4-31.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-31.png" class="lazyload"></a></p><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。</p><p>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。</p><hr><p><strong>BGP 发言人交换路径向量</strong></p><p><a href="/pic/network/4-32.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-32.png" class="lazyload"></a></p><p>自治系统 AS<sub>2</sub> 的 BGP 发言人通知主干网的 BGP 发言人：“要到达网络 N<sub>1</sub>, N<sub>2</sub>, N<sub>3</sub> 和 N<sub>4</sub> 可经过 AS<sub>2</sub>”；</p><p>主干网还可发出通知：“要到达网络 N<sub>5</sub>, N<sub>6</sub> 和 N<sub>7</sub> 可沿路径（AS<sub>1</sub>,AS<sub>3</sub>）” ；</p><hr><p><strong>BGP 协议的特点</strong></p><ul><li>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。</li><li>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。</li><li>BGP 支持 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。</li><li>在BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。</li></ul><hr><p><strong>BGP-4 报文种类</strong></p><ol><li>打开(OPEN)报文：用来与相邻的另一个BGP发言人建立关系。</li><li>更新(UPDATE)报文：用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活(KEEPALIVE)报文：用来确认打开报文和周期性地证实邻站关系。</li><li>通知(NOTIFICATION)报文：用来发送检测到的差错。</li></ol><p><strong>BGP 报文具有通用的首部</strong></p><p><a href="/pic/network/4-33.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-33.png" class="lazyload"></a></p><h3 id="25-路由器在网际互连中的作用"><a class="markdownIt-Anchor" href="#25-路由器在网际互连中的作用"></a> 2.5 路由器在网际互连中的作用</h3><p><strong>路由器的结构</strong></p><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是<strong>转发分组</strong>。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。</p><p><a href="/pic/network/4-34.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-34.png" class="lazyload"></a></p><hr><p><strong>“转发”和“路由选择”的区别</strong></p><ul><li><p>“转发”(forwarding)就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。</p></li><li><p>“路由选择”(routing)则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。</p></li><li><p>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。</p></li><li><p>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</p></li></ul><hr><p>输入端口对线路上收到的分组的处理：</p><p>数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。</p><p><a href="/pic/network/4-35.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-35.png" class="lazyload"></a></p><p>输出端口将交换结构传送来的分组发送到线路：</p><p>当交换结构传送过来的分组先进行缓存。数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</p><p><a href="/pic/network/4-36.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-36.png" class="lazyload"></a></p><hr><p><strong>分组丢弃</strong></p><p>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。</p><p>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</p><h2 id="3-ip多播"><a class="markdownIt-Anchor" href="#3-ip多播"></a> 3 IP多播</h2><h3 id="31-ip-多播的基本概念"><a class="markdownIt-Anchor" href="#31-ip-多播的基本概念"></a> 3.1 IP 多播的基本概念</h3><p><a href="/pic/network/4-37.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-37.png" class="lazyload"></a></p><p>多播可明显地减少网络中资源的消耗</p><hr><p><strong>IP 多播的特点</strong></p><ol><li>多播使用组地址：IP 使用 D 类地址支持多播。多播地址只能用于目的地址，而不能用于源地址；</li><li>永久组地址：由因特网号码指派管理局 IANA 负责指派；</li><li>动态的组成员；</li><li>使用硬件进行多播；</li></ol><h3 id="32-在局域网上进行硬件多播"><a class="markdownIt-Anchor" href="#32-在局域网上进行硬件多播"></a> 3.2 在局域网上进行硬件多播</h3><p>因特网号码指派管理局 IANA 拥有的以太网地址块的高 24 位为 00-00-5E。</p><p>因此 TCP/IP 协议使用的以太网多播地址块的范围是：从 00-00-5E-00-00-00 到 00-00-5E-FF-FF-FF</p><p>D 类 IP 地址可供分配的有 28 位，在这 28 位中的前 5 位不能用来构成以太网硬件地址。</p><hr><p>D 类 IP 地址与以太网多播地址的映射关系</p><p><a href="/pic/network/4-38.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-38.png" class="lazyload"></a></p><h3 id="33-网际组管理协议-igmp-和多播路由选择协议"><a class="markdownIt-Anchor" href="#33-网际组管理协议-igmp-和多播路由选择协议"></a> 3.3 网际组管理协议 IGMP 和多播路由选择协议</h3><p><strong>IP多播需要两种协议</strong></p><ol><li>为了使路由器知道多播组成员的信息，需要利用<strong>网际组管理协议 IGMP</strong>。</li><li>连接在局域网上的多播路由器还必须和因特网上的其他多播路由器协同工作，以便把多播数据报用最小代价传送给所有的组成员。这就需要使用<strong>多播路由选择协议</strong>。</li></ol><p><a href="/pic/network/4-39.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-39.png" class="lazyload"></a></p><p><strong>IGMP 的本地使用范围</strong></p><ul><li>IGMP 并非在因特网范围内对所有多播组成员进行管理的协议。</li><li>IGMP 不知道 IP 多播组包含的成员数，也不知道这些成员都分布在哪些网络上。</li><li>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机（严格讲，是主机上的某个进程）参加或退出了某个多播组。</li></ul><p>多播路由选择协议比单播路由选择协议复杂得多：</p><ul><li>多播转发必须<strong>动态地适应</strong>多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。</li><li>多播路由器在转发多播数据报时，不能仅仅根据多播数据报中的目的地址，而是还要考虑这个多播数据报从什么地方来和要到什么地方去。</li><li>多播数据报可以由没有加入多播组的主机发出，也可以通过没有组成员接入的网络。</li></ul><hr><p>IGMP 是整个网际协议 IP 的一个组成部分和 ICMP 相似，IGMP 使用 IP 数据报传递其报文（即 IGMP 报文加上 IP 首部构成 IP 数据报），但它也向 IP 提供服务。因此，我们不把 IGMP 看成是一个单独的协议，而是属于整个网际协议 IP 的一个组成部分。</p><p><strong>IGMP 可分为两个阶段</strong></p><ul><li>第一阶段：当某个主机加入新的多播组时，该主机应向多播组的多播地址发送IGMP 报文，声明自己要成为该组的成员。本地的多播路由器收到 IGMP 报文后，将组成员关系转发给因特网上的其他多播路由器。</li><li>第二阶段：因为组成员关系是动态的，因此本地多播路由器要周期性地探询本地局域网上的主机，以便知道这些主机是否还继续是组的成员。只要对某个组有一个主机响应，那么多播路由器就认为这个组是活跃的。但一个组在经过几次的探询后仍然没有一个主机响应，则不再将该组的成员关系转发给其他的多播路由器。</li></ul><hr><p><strong>IGMP 采用的一些具体措施</strong></p><ul><li>在主机和多播路由器之间的所有通信都是使用 IP 多播。</li><li>多播路由器在探询组成员关系时，只需要对所有的组发送一个请求信息的询问报文，而不需要对每一个组发送一个询问报文。默认的询问速率是每 125 秒发送一次。</li><li>当同一个网络上连接有几个多播路由器时，它们能够迅速和有效地选择其中的一个来探询主机的成员关系。</li><li>在 IGMP 的询问报文中有一个数值 <em>N</em>，它指明一个最长响应时间（默认值为 10秒）。当收到询问时，主机在 0 到 <em>N</em> 之间随机选择发送响应所需经过的时延。对应于最小时延的响应最先发送。</li><li>同一个组内的每一个主机都要监听响应，只要有本组的其他主机先发送了响应，自己就可以不再发送响应了。</li></ul><hr><p><strong>多播路由选择</strong></p><ul><li>多播路由选择协议尚未标准化。</li><li>一个多播组中的成员是动态变化的，随时会有主机加入或离开这个多播组。</li><li>多播路由选择实际上就是要找出以源主机为根结点的<strong>多播转发树</strong>。</li><li>在多播转发树上的路由器不会收到重复的多播数据报。</li><li>对不同的多播组对应于不同的多播转发树。同一个多播组，对不同的源点也会有不同的多播转发树。</li></ul><hr><p><strong>转发多播数据报使用的方法</strong></p><p>（一）洪泛与剪除</p><p>这种方法适合于较小的多播组，而所有的组成员接入的局域网也是相邻接的。</p><p>一开始，路由器转发多播数据报使用洪泛的方法（这就是广播）。为了避免兜圈子，采用了叫做反向路径广播 RPB (Reverse Path Broadcasting)的策略。</p><p><strong>RPB 的要点</strong></p><ol><li>路由器收到多播数据报时，先检查是否从源点经最短路径传送来的。</li><li>若是，就向所有其他方向转发刚才收到的多播数据报（但进入的方向除外），否则就丢弃而不转发。</li><li>如果存在几条同样长度的最短路径，那么只能选择一条最短路径，选择的准则就是看这几条最短路径中的相邻路由器谁的 IP 地址最小。</li></ol><p><a href="/pic/network/4-40.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-40.png" class="lazyload"></a></p><p>（二）隧道技术</p><p><a href="/pic/network/4-41.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-41.png" class="lazyload"></a></p><p>（三）基于核心的发现技术</p><p>这种方法对于多播组的大小在较大范围内变化时都适合。</p><p>这种方法是对每一个多播组 G 指定一个核心(core)路由器，给出它的 IP 单播地址。</p><p>核心路由器按照前面讲过的方法创建出对应于多播组 G 的转发树。</p><h2 id="4-虚拟专用网-vpn-和网络地址转换-nat"><a class="markdownIt-Anchor" href="#4-虚拟专用网-vpn-和网络地址转换-nat"></a> 4 虚拟专用网 VPN 和网络地址转换 NAT</h2><h3 id="41-虚拟专用网-vpn"><a class="markdownIt-Anchor" href="#41-虚拟专用网-vpn"></a> 4.1 虚拟专用网 VPN</h3><ul><li>本地地址：仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向因特网的管理机构申请。</li><li>全球地址：全球唯一的IP地址，必须向因特网的管理机构申请。</li></ul><p>RFC 1918 指明的专用地址：</p><ul><li>10.0.0.0 到 10.255.255.255</li><li>172.16.0.0 到 172.31.255.255</li><li>192.168.0.0 到 192.168.255.255</li></ul><p>这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。专用地址只能用作本地地址而不能用作全球地址。在因特网中的所有路由器对目的地址是专用地址的数据报一律不进行转发。</p><p>用隧道技术可以实现虚拟专用网</p><p><a href="/pic/network/4-42.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-42.png" class="lazyload"></a></p><hr><p><strong>内联网和外联网</strong></p><p>内联网和外联网都是基于 TCP/IP 协议。</p><ul><li>由部门 A 和 B 的内部网络所构成的虚拟专用网 VPN 又称为内联网(intranet)，表示部门 A 和 B 都是在同一个机构的内部。</li><li>一个机构和某些外部机构共同建立的虚拟专用网 VPN 又称为外联网(extranet)。</li></ul><hr><p><strong>远程接入VPN</strong></p><p>有的公司可能没有分布在不同场所的部门，但有很多流动员工在外地工作。公司需要和他们保持联系，远程接入 VPN 可满足这种需求。</p><p>在外地工作的员工拨号接入因特网，而驻留在员工 PC 机中的 VPN 软件可在员工的 PC 机和公司的主机之间建立 VPN 隧道，因而外地员工与公司通信的内容是保密的，员工们感到好像就是使用公司内部的本地网络。</p><h3 id="42-网络地址转换-nat"><a class="markdownIt-Anchor" href="#42-网络地址转换-nat"></a> 4.2 网络地址转换 NAT</h3><p>网络地址转换 NAT 方法于1994年提出。</p><p>需要在专用网连接到因特网的路由器上安装 NAT 软件。装有 NAT 软件的路由器叫做 NAT路由器，它至少有一个有效的外部全球地址 IP<sub><em>G</em></sub>。</p><p>所有使用本地地址的主机在和外界通信时都要在 NAT 路由器上将其本地地址转换成 IP<sub><em>G</em></sub> 才能和因特网连接。</p><hr><p><strong>网络地址转换的过程</strong></p><ol><li>内部主机 X 用本地地址 IP<sub><em>x</em></sub> 和因特网上主机 Y 通信所发送的数据报必须经过 NAT 路由器。</li><li>NAT 路由器将数据报的源地址 IP<sub><em>x</em></sub> 转换成全球地址 IP<sub><em>G</em></sub>，但目的地址 IP<sub><em>Y</em></sub> 保持不变，然后发送到因特网。</li><li>NAT 路由器收到主机 Y 发回的数据报时，知道数据报中的源地址是 IP<sub><em>Y</em></sub> 而目的地址是 IP<sub><em>G</em></sub>。</li><li>根据 NAT 转换表，NAT 路由器将目的地址 IP<sub><em>G</em></sub> 转换为 IP<sub><em>x</em></sub>，转发给最终的内部主机 X。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(四)：网络层(一)</title>
      <link href="/2020/02/02/network-4-1/"/>
      <url>/2020/02/02/network-4-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络层提供的两种服务"><a class="markdownIt-Anchor" href="#1-网络层提供的两种服务"></a> 1 网络层提供的两种服务</h2><p>在计算机网络领域，网络层应该向运输层提供怎样的服务（“面向连接”还是“无连接”）曾引起了长期的争论。</p><p>争论焦点的实质就是：在计算机通信中，<strong>可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</p><p><strong>电信网的成功经验让网络负责可靠交付</strong>：<strong>面向连接</strong>的通信方式；建立虚电路(Virtual Circuit)，以保证双方通信所需的一切网络资源；如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点。</p><p><a href="/pic/network/4-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-1.png" class="lazyload"></a></p><p><strong>虚电路是逻辑连接</strong>：虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。请注意，电路交换的电话通信是先建立了一条真正的连接。因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</p><p><strong>因特网采用的设计思路</strong>：网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务。</p><p>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。网络层不提供服务质量的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</p><p><strong>尽最大努力交付的好处</strong></p><ul><li>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。</li><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。</li><li>采用这种设计思路的好处是：<strong>网络的造价大大降低，运行方式灵活，能够适应多种应用</strong>。</li><li>因特网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul><p><a href="/pic/network/4-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-2.png" class="lazyload"></a></p><p><strong>虚电路服务</strong>与<strong>数据报服务</strong>的对比</p><table><thead><tr><th style="text-align:center">对比的方面</th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">可靠通信应当由网络来保证</td><td style="text-align:center">可靠通信应当由用户主机来保证</td></tr><tr><td style="text-align:center">连接的建立</td><td style="text-align:center">必须有</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">终点地址</td><td style="text-align:center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组的转发</td><td style="text-align:center">属于同一条虚电路的分组均按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当结点出故障时</td><td style="text-align:center">所有通过出故障的结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按发送顺序到达终点</td><td style="text-align:center">到达终点时不一定按发送顺序</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可以由网络负责，也可以由用户主机负责</td><td style="text-align:center">由用户主机负责</td></tr></tbody></table><h2 id="2-网际协议ip"><a class="markdownIt-Anchor" href="#2-网际协议ip"></a> 2 网际协议IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有四个协议：</p><ol><li><strong>地址解析协议 ARP</strong>  (Address Resolution Protocol)</li><li><strong>逆地址解析协议 RARP</strong>  (Reverse Address Resolution Protocol)</li><li><strong>网际控制报文协议 ICMP</strong>  (Internet Control Message Protocol)</li><li><strong>网际组管理协议 IGMP</strong>  (Internet Group Management Protocol)</li></ol><p><a href="/pic/network/4-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-3.png" class="lazyload"></a></p><h3 id="21-虚拟互连网络"><a class="markdownIt-Anchor" href="#21-虚拟互连网络"></a> 2.1 虚拟互连网络</h3><p>互连在一起的网络要进行通信，会遇到许多问题需要解决，如不同的寻址方案、不同的最大分组长度、不同的网络接入机制、不同的超时控制等。</p><p>网络互相连接起来要使用一些<strong>中间设备</strong>，中间设备又称为中间系统或中继(relay)系统。</p><ul><li>物理层中继系统：<strong>转发器</strong>(repeater)。</li><li>数据链路层中继系统：<strong>网桥或桥接器</strong>(bridge)。</li><li>网络层中继系统：<strong>路由器</strong>(router)。</li><li>网桥和路由器的混合物：<strong>桥路器</strong>(brouter)。</li><li>网络层以上的中继系统：<strong>网关</strong>(gateway)。</li></ul><p><strong>网络互连使用路由器</strong></p><p>当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络；网关由于比较复杂，目前使用得较少；互联网都是指用<strong>路由器</strong>进行互连的网络。由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为网关。</p><p><strong>虚拟互连网络的意义</strong></p><p>所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是一个统一的网络。</p><p>使用 IP 协议的虚拟互连网络可简称为 IP 网。</p><p>使用虚拟互连网络的好处：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。</p><p><a href="/pic/network/4-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-4.png" class="lazyload"></a></p><p>从网络层看 IP 数据报的传送：如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送。</p><h3 id="22-分类的-ip-地址"><a class="markdownIt-Anchor" href="#22-分类的-ip-地址"></a> 2.2 分类的 IP 地址</h3><h4 id="221-ip-地址及其表示方法"><a class="markdownIt-Anchor" href="#221-ip-地址及其表示方法"></a> 2.2.1 IP 地址及其表示方法</h4><p>我们把整个因特网看成为一个单一的、抽象的网络。IP 地址就是给每个连接在因特网上的主机（或路由器）分配一个在全世界范围是唯一的 32 位的标识符。</p><p><strong>IP 地址的编址方法</strong></p><ul><li><strong>分类的 IP 地址</strong>：这是最基本的编址方法，在 1981 年就通过了相应的标准协议。</li><li><strong>子网的划分</strong>：这是对最基本的编址方法的改进，其标准[RFC 950]在 1985 年通过。</li><li><strong>构成超网</strong>：这是比较新的无分类编址方法。1993 年提出后很快就得到推广应用。</li></ul><p><strong>分类 IP 地址</strong></p><p>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号</strong> net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号</strong> host-id，它标志该主机（或路由器）。两级的 IP 地址可以记为：</p><pre class="highlight"><code class>IP 地址 ::= { &lt;网络号&gt;, &lt;主机号&gt;}     （::= 代表“定义为”）</code></pre><p><a href="/pic/network/4-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-5.png" class="lazyload"></a></p><p><strong>点分十进制记法</strong></p><p><a href="/pic/network/4-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-6.png" class="lazyload"></a></p><h4 id="222-常用的三种类别的-ip-地址"><a class="markdownIt-Anchor" href="#222-常用的三种类别的-ip-地址"></a> 2.2.2 常用的三种类别的 IP 地址</h4><p>IP 地址的使用范围</p><table><thead><tr><th style="text-align:center">网络类别</th><th style="text-align:center">最大网络数</th><th style="text-align:center">第一个可用的网络号</th><th style="text-align:center">最后一个可用的网络号</th><th style="text-align:center">每个网络中最大的主机数</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">126 (2<sup>7</sup> – 2)</td><td style="text-align:center">1</td><td style="text-align:center">126</td><td style="text-align:center">16,777,214</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">16,383(2<sup>14</sup> - 1)</td><td style="text-align:center">128.1</td><td style="text-align:center">191.255</td><td style="text-align:center">65,534</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">2,097,151 (2<sup>21</sup> - 1)</td><td style="text-align:center">192.0.1</td><td style="text-align:center">223.255.255</td><td style="text-align:center">254</td></tr></tbody></table><p><strong>IP 地址的重要特点</strong></p><ol><li>IP 地址是一种分等级的地址结构，分两个等级的好处是：<ol><li>IP 地址管理机构在分配 IP 地址时<strong>只分配网络号</strong>，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li>路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ol></li><li>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口。<ol><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong>(multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器<strong>至少</strong>应当有两个不同的 IP 地址。</li></ol></li><li>用<strong>转发器或网桥</strong>连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。</li><li>所有分配到网络号 net-id 的网络，范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</li></ol><p><a href="/pic/network/4-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-7.png" class="lazyload"></a></p><ul><li>在同一个局域网上的主机或路由器的 IP 地址中的网络号必须是一样的，图中的网络号就是 IP 地址中的 net-id。</li><li>路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。</li><li>两个路由器直接相连的接口处，可指明也可不指明 IP 地址。如指明 IP 地址，则这一段连线就构成了一种只包含一段线路的特殊“网络” 。现在常不指明 IP 地址。</li></ul><h3 id="23-ip-地址与硬件地址"><a class="markdownIt-Anchor" href="#23-ip-地址与硬件地址"></a> 2.3 IP 地址与硬件地址</h3><p><a href="/pic/network/4-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-8.png" class="lazyload"></a></p><p>从三个不同的层次看数据的流动过程</p><p><a href="/pic/network/4-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-9.png" class="lazyload"></a></p><p><a href="/pic/network/4-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-10.png" class="lazyload"></a></p><p>在 IP 层抽象的互联网上只能看到 IP 数据报图中的 IP1<strong>→</strong>IP2 表示从源地址 IP1 到目的地址 IP2 两个路由器的 IP 地址并不出现在 IP 数据报的首部中。</p><p>路由器只根据目的站的 IP 地址的网络号进行路由选择。</p><p>IP层抽象的互联网屏蔽了下层很复杂的细节在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信。</p><p><a href="/pic/network/4-11.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-11.png" class="lazyload"></a></p><p>在具体的物理网络的链路层只能看见 MAC 帧而看不见 IP 数据报。</p><h3 id="24-地址解析协议-arp-和逆地址解析协议-rarp"><a class="markdownIt-Anchor" href="#24-地址解析协议-arp-和逆地址解析协议-rarp"></a> 2.4 地址解析协议 ARP 和逆地址解析协议 RARP</h3><p><a href="/pic/network/4-12.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-12.png" class="lazyload"></a></p><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。</p><p>每一个主机都设有一个 <strong>ARP 高速缓存</strong>(ARP cache)，里面有所在的局域网上的各主机和路由器的 <strong>IP 地址到硬件地址</strong>的映射表。当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。</p><p><a href="/pic/network/4-13.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-13.png" class="lazyload"></a></p><p><strong>ARP 高速缓存的作用</strong>：为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</p><p>ARP 是解决<strong>同一个局域网</strong>上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><p>从IP地址到硬件地址的解析是<strong>自动进行</strong>的，主机的用户对这种地址解析过程是不知道的。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。</p><p><strong>使用 ARP 的四种典型情况</strong></p><ol><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ol><p><strong>什么我们不直接使用硬件地址进行通信？</strong></p><p>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。</p><p>连接到因特网的主机都拥有统一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为调用 ARP 来寻找某个路由器或主机的硬件地址都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。</p><p>逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。这种主机往往是无盘工作站，因此 RARP协议目前已很少使用。</p><h3 id="25-ip-数据报的格式"><a class="markdownIt-Anchor" href="#25-ip-数据报的格式"></a> 2.5 IP 数据报的格式</h3><p>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。</p><p><a href="/pic/network/4-14.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-14.png" class="lazyload"></a></p><p><strong>版本</strong>：占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)</p><p><strong>首部长度</strong>：占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。</p><p><strong>区分服务</strong>：占 8 位，用来获得更好的服务。在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段。</p><p><strong>总长度</strong>：占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</p><p><strong>标识</strong>：占 16 位，它是一个计数器，用来产生数据报的标识。</p><p><strong>标志</strong>：占 3 位，目前只有前两位有意义。标志字段的最低位是 <strong>MF</strong> (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 <strong>DF</strong> (Don’t Fragment) 。只有当 DF = 0 时才允许分片。</p><p><strong>片偏移</strong>：占12 位，指出较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</p><p><a href="/pic/network/4-15.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-15.png" class="lazyload"></a></p><p><strong>生存时间</strong>：占8 位，记为 TTL (Time To Live)，数据报在网络中可通过的路由器数的最大值。</p><p><strong>协议</strong>：占8 位，字段指出此数据报携带的数据使用何种协议以便目的主机的 IP 层将数据部分上交给哪个处理过程。协议包括TCP、UDP、ICMP、IGMP、OSPF等。</p><p><strong>首部检验和</strong>：占16 位，字段只检验数据报的首部不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。</p><p><a href="/pic/network/4-16.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-16.png" class="lazyload"></a></p><p><strong>源地址和目的地址</strong>：都各占 4 字节</p><p><strong>IP 数据报首部的可变部分</strong></p><p>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。</p><p>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。</p><p>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。</p><h3 id="26-ip-层转发分组的流程"><a class="markdownIt-Anchor" href="#26-ip-层转发分组的流程"></a> 2.6 IP 层转发分组的流程</h3><p>有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。可以想像，若按目的主机号来制作路由表，则所得出的路由表就会过于庞大。但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目。这样就可使路由表大大简化。</p><p><a href="/pic/network/4-17.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-17.png" class="lazyload"></a></p><p><strong>查找路由表</strong>：根据目的网络地址就能确定下一跳路由器，这样做的结果是：</p><ul><li>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。</li><li>只有到达最后一个路由器时，才试图向目的主机进行直接交付。</li></ul><p><strong>特定主机路由</strong>：这种路由是为特定的目的主机指明一个路由。采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。</p><p><strong>默认路由</strong>：路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。默认路由在主机发送 IP 数据报时往往更能显示出它的好处。如果一个主机连接在一个小网络上，而这个网络只用一个路由器和因特网连接，那么在这种情况下使用默认路由是非常合适的。</p><p><a href="/pic/network/4-18.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-18.png" class="lazyload"></a></p><p>只要目的网络不是 N<sub>1</sub> 和 N<sub>2</sub>，就一律选择默认路由，把数据报先间接交付路由器 R<sub>1</sub>，让 R<sub>1</sub> 再转发给下一个路由器。</p><p>IP 数据报的首部中没有地方可以用来指明“下一跳路由器的 IP 地址”。当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是送交下层的网络接口软件。网络接口软件使用 ARP 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p><p><strong>分组转发算法</strong></p><ol><li>从数据报的首部提取目的主机的 IP 地址 <em>D</em>, 得出目的网络地址为 <em>N</em>。</li><li>若网络 <em>N</em> 与此路由器直接相连，则把数据报直接交付目的主机 <em>D</em>；否则是间接交付，执行3。</li><li>若路由表中有目的地址为 <em>D</em> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行4。</li><li>若路由表中有到达网络 <em>N</em> 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行5。</li><li>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行6。</li><li>报告转发分组出错。</li></ol><h2 id="3-划分子网和构造超网"><a class="markdownIt-Anchor" href="#3-划分子网和构造超网"></a> 3 划分子网和构造超网</h2><h3 id="31-划分子网"><a class="markdownIt-Anchor" href="#31-划分子网"></a> 3.1 划分子网</h3><p>在 ARPANET 的早期，IP 地址的设计确实不够合理。</p><ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li></ul><p>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为三级的 IP 地址。这种做法叫作<strong>划分子网</strong>(subnetting) 。划分子网已成为因特网的正式标准协议。</p><p><strong>划分子网的基本思路</strong></p><p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p><pre class="highlight"><code class>IP地址 ::= {&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}       </code></pre><p>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。</p><p><a href="/pic/network/4-19.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-19.png" class="lazyload"></a></p><p>划分子网后变成了三级结构：当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址就变成了三级结构。划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号 net-id。</p><p><strong>子网掩码</strong></p><p>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。使用子网掩码(subnet mask)可以找出 IP 地址中的子网部分。</p><p><a href="/pic/network/4-20.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-20.png" class="lazyload"></a></p><p>子网掩码是一个网络或一个子网的重要属性。</p><ul><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</li></ul><h3 id="32-使用子网掩码的分组转发过程"><a class="markdownIt-Anchor" href="#32-使用子网掩码的分组转发过程"></a> 3.2 使用子网掩码的分组转发过程</h3><p>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但数据报的首部并没有提供子网掩码的信息。因此分组转发的算法也必须做相应的改动。</p><p><strong>在划分子网的情况下路由器转发分组的算法</strong></p><ol><li>从收到的分组的首部提取目的 IP 地址 <em>D</em>。</li><li>先用各网络的子网掩码和 <em>D</em> 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行(3)。</li><li>若路由表中有目的地址为 <em>D</em> 的<strong>特定主机路由</strong>，则将分组传送给指明的下一跳路由器；否则，执行(4)。</li><li>对路由表中的每一行的子网掩码和 <em>D</em> 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行(5)。</li><li>若路由表中有一个<strong>默认路由</strong>，则将分组传送给路由表中所指明的默认路由器；否则，执行(6)。</li><li>报告转发分组出错。</li></ol><p><a href="/pic/network/4-21.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-21.png" class="lazyload"></a></p><p>已知互联网和路由器 R1 中的路由表。主机 H1 向 H2 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。</p><ol><li>主机 H1 要发送分组给 H2，要发送的分组的目的 IP 地址：128.30.33.138。因此 H1 首先检查主机 128.30.33.138 是否连接在本网络上如果是，则直接交付；否则，就送交路由器 R1，并逐项查找路由表。</li><li>主机 H1 首先将本子网的子网掩码 255.255.255.128 与分组的 IP 地址 128.30.33.138 逐比特相“与”(AND 操作) ，发现不等于 H1 的网络地址。</li><li>因此 H1 必须把分组传送到路由器 R1然后逐项查找路由表。路由器 R1 收到分组后就用路由表中第 1 个项目的<br>子网掩码和 128.30.33.138 逐比特 AND 操作，结果与 128.30.33.0 不匹配。</li><li>路由器 R1 再用路由表中第 2 个项目的子网掩码和 128.30.33.138 逐比特 AND 操作，与 128.30.33.128 匹配，这表明子网 2 就是收到的分组所要寻找的目的网络。</li></ol><h3 id="33-无分类编址-cidr"><a class="markdownIt-Anchor" href="#33-无分类编址-cidr"></a> 3.3 无分类编址 CIDR</h3><p>划分子网在一定程度上缓解了因特网在发展中遇到的困难。然而在 1992 年因特网仍然面临三个必须尽早解决的问题，这就是：</p><ol><li>B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！</li><li>因特网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。</li><li>整个 IPv4 的地址空间最终将全部耗尽。</li></ol><p>无分类编址方法，它的正式名字是无分类域间路由选择 CIDR。</p><p>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。IP 地址从三级编址（使用子网掩码）又回到了两级编址。</p><p><strong>无分类的两级编址</strong></p><p>无分类的两级编址的记法是：</p><pre class="highlight"><code class>IP地址 ::= {&lt;网络前缀&gt;, &lt;主机号&gt;}           </code></pre><p>CIDR 还使用“<strong>斜线记法</strong>”(slash notation)，它又称为CIDR记法，即在 IP 地址面加上一个斜线“/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中子网掩码中 1 的个数）。</p><p>CIDR 把网络前缀都相同的连续的 IP 地址组成“<strong>CIDR 地址块</strong>”。</p><p><strong>CIDR 地址块</strong></p><p>128.14.32.0/20 表示的地址块共有 2<sup>12</sup> 个地址（因为斜线后面的 20 是网络前缀的位数，所以这个地址的主机号是 12 位）。这个地址块的起始地址是 128.14.32.0。在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。128.14.32.0/20 地址块的最小地址：128.14.32.0；最大地址：128.14.47.255。全 0 和全 1 的主机号地址一般不使用。</p><p><strong>路由聚合</strong></p><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为<strong>路由聚合</strong>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。路由聚合也称为<strong>构成超网</strong>(supernetting)。</p><p>CIDR 虽然不使用子网了，但仍然使用“<strong>掩码</strong>”这一名词（但不叫子网掩码）。对于 /20 地址块，它的掩码是 20 个连续的 1。 斜线记法中的数字就是掩码中1的个数。</p><p><strong>CIDR 记法的其他形式</strong></p><p>10.0.0.0/10 可简写为 10/10，也就是将点分十进制中低位连续的 0 省略。</p><p>10.0.0.0/10 相当于指出 IP 地址 10.0.0.0 的掩码是 255.192.0.0，即11111111 11000000 00000000 00000000</p><p>网络前缀的后面加一个星号 * 的表示方法，如 00001010 00*，在星号 * 之前是网络前缀，而星号 * 表示 IP 地址中的主机号，可以是任意值。</p><p><strong>构成超网</strong></p><p>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。这些 C 类地址合起来就构成了<strong>超网</strong>。</p><p>CIDR 地址块中的地址数一定是 2 的整数次幂。网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的IP地址中，划分子网是使网络前缀变长。</p><p><a href="/pic/network/4-22.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-22.png" class="lazyload"></a></p><p><strong>最长前缀匹配</strong></p><p>使用 CIDR 时，路由表中的每个项目由“<strong>网络前缀</strong>”和“<strong>下一跳地址</strong>”组成。在查找路由表时可能会得到不止一个匹配结果。 应当从匹配结果中选择具有最长网络前缀的路由：<strong>最长前缀匹配</strong>。网络前缀越长，其地址块就越小，因而路由就越具体。最长前缀匹配又称为最长匹配或最佳匹配。</p><p><strong>使用二叉线索查找路由表</strong></p><p>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。 为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong>(binary trie)。</p><p>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。为了提高二叉线索的查找速度，广泛使用了各种压缩技术。</p><p><a href="/pic/network/4-23.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/4-23.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(三)：数据链路层</title>
      <link href="/2020/01/30/network-3/"/>
      <url>/2020/01/30/network-3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-数据链路层的简单模型"><a class="markdownIt-Anchor" href="#1-数据链路层的简单模型"></a> 1 数据链路层的简单模型</h2><p><a href="/pic/network/3-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-1.png" class="lazyload"></a></p><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li><strong>点对点信道</strong>：这种信道使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的<strong>共享信道协议</strong>来协调这些主机的数据发送。</li></ul><h2 id="2-使用点对点信道的数据链路层"><a class="markdownIt-Anchor" href="#2-使用点对点信道的数据链路层"></a> 2 使用点对点信道的数据链路层</h2><h3 id="21-数据链路和帧"><a class="markdownIt-Anchor" href="#21-数据链路和帧"></a> 2.1 数据链路和帧</h3><p><strong>链路</strong>(link)：一条无源的点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</p><p><strong>数据链路</strong>(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。</p><p>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</p><p><a href="/pic/network/3-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-2.png" class="lazyload"></a></p><h3 id="22-三个基本问题"><a class="markdownIt-Anchor" href="#22-三个基本问题"></a> 2.2 三个基本问题</h3><h4 id="221-封装成帧"><a class="markdownIt-Anchor" href="#221-封装成帧"></a> 2.2.1 封装成帧</h4><p><a href="/pic/network/3-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-3.png" class="lazyload"></a></p><p>封装成帧(framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧，确定帧的界限。</p><p>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</p><h4 id="222-透明传输"><a class="markdownIt-Anchor" href="#222-透明传输"></a> 2.2.2 透明传输</h4><p><a href="/pic/network/3-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-4.png" class="lazyload"></a></p><p><strong>解决透明传输问题</strong>：发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)。</p><p>字节填充(byte stuffing)或字符填充(character stuffing)——接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</p><p>如果转义字符也出现数据当中，那么应在转义字符前面插入一个转义字符。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</p><p><a href="/pic/network/3-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-5.png" class="lazyload"></a></p><h4 id="223-差错检测"><a class="markdownIt-Anchor" href="#223-差错检测"></a> 2.2.3 差错检测</h4><p>在传输过程中可能会产生比特差错：1 可能会变成 0 而 0 也可能变成 1。</p><p>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong> BER (Bit Error Rate)。</p><p>误码率与信噪比有很大的关系。</p><p>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p><p><strong>循环冗余检验的原理</strong></p><p>在发送端，先把数据划分为组，假定每组 <em>k</em> 个比特。假设待传送的一组数据 <em>M</em> = 101001（现在 <em>k</em> = 6）。我们在 <em>M</em> 的后面再添加供差错检测用的 <em>n</em> 位冗余码一起发送。</p><p>接收端对收到的每一帧进行 CRC 检验，若得出的余数 <em>R</em> = 0，则判定这个帧没有差错，就接受(accept)；若余数 <em>R</em> ≠ 0，则判定这个帧有差错，就丢弃。</p><p>但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错。只要经过严格的挑选，并使用位数足够多的除数 <em>P</em>，那么出现检测不到的差错的概率就很小很小。</p><p><strong>冗余码的计算</strong></p><p>用二进制的模 2 运算进行 2<sup>n</sup> 乘 <em>M</em> 的运算，这相当于在 <em>M</em> 后面添加 <em>n</em> 个 0。</p><p>得到的 (<em>k</em> + <em>n</em>) 位的数除以事先选定好的长度为 (<em>n</em> + 1) 位的除数 <em>P</em>，得出商是 <em>Q</em> 而余数是 <em>R</em>，余数 <em>R</em> 比除数 <em>P</em> 少1 位，即 <em>R</em> 是 <em>n</em> 位。</p><p><strong>例如</strong>：现在 <em>k</em> = 6, <em>M</em> = 101001。</p><p>设 <em>n</em> = 3, 除数 <em>P</em> = 1101，</p><p>被除数是 2<sup>n</sup><em>M</em> = 101001000。</p><p>模 2 运算的结果是：商 <em>Q</em> = 110101，余数 <em>R</em> = 001。</p><p>把余数 <em>R</em> 作为冗余码添加在数据 <em>M</em> 的后面发送出去。发送的数据是：2<sup>n</sup><em>M</em> + <em>R</em> 即：101001001，共 (<em>k</em> + <em>n</em>) 位。</p><p><strong>帧检验序列 FCS</strong></p><p>在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。循环冗余检验 CRC 和帧检验序列 FCS并不等同。CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。</p><p><strong>注意</strong>：仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。“无差错接受”是指：“凡是接受的帧（即不包括丢弃的帧），我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说：“凡是接收端数据链路层接受的帧都没有传输差错”（有差错的帧就丢弃而不接受）。要做到“可靠传输”（即发送什么就收到什么）就必须再加上确认和重传机制。</p><h2 id="3-点对点协议-ppp"><a class="markdownIt-Anchor" href="#3-点对点协议-ppp"></a> 3 点对点协议 PPP</h2><h3 id="31-ppp-协议的特点"><a class="markdownIt-Anchor" href="#31-ppp-协议的特点"></a> 3.1 PPP 协议的特点</h3><p><a href="/pic/network/3-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-6.png" class="lazyload"></a></p><p>现在全世界使用得最多的数据链路层协议是点对点协议 PPP (Point-to-Point Protocol)。用户使用拨号电话线接入因特网时，一般都是使用 PPP 协议。</p><p>PPP 协议应满足的需求：简单(这是首要的要求)、封装成帧、透明性、多种网络层协议、多种类型链路、差错检测、检测连接状态、最大传送单元、网络层地址协商、数据压缩协商。</p><p>PPP 协议不需要的功能：纠错、流量控制、序号、多点线路、半双工或单工链路。</p><p><strong>PPP 协议的组成</strong></p><ol><li>一个将 IP 数据报封装到串行链路的方法。</li><li>链路控制协议 LCP (Link Control Protocol)。</li><li>网络控制协议 NCP (Network Control Protocol)。</li></ol><h3 id="32-ppp-协议的帧格式"><a class="markdownIt-Anchor" href="#32-ppp-协议的帧格式"></a> 3.2 PPP 协议的帧格式</h3><p><a href="/pic/network/3-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-7.png" class="lazyload"></a></p><ul><li>标志字段 F = 0x7E。</li><li>地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</li><li>控制字段 C 通常置为 0x03。</li><li>PPP 有一个 2 个字节的协议字段：当协议字段为 0x0021 时，PPP 帧的信息字段就是IP 数据报；若为 0xC021, 则信息字段是 PPP 链路控制数据；若为 0x8021，则表示这是网络控制数据。</li><li>PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节。</li></ul><p><strong>透明传输问题</strong></p><p>字符填充：用于异步传输。</p><ol><li>将信息字段中出现的每一个 0x7E 字节转变成为 2 字节序列(0x7D, 0x5E)。</li><li>若信息字段中出现一个 0x7D 的字节, 则将其转变成为 2 字节序列(0x7D, 0x5D)。</li><li>若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前面要加入一个 0x7D 字节，同时将该字符的编码加以改变。</li></ol><p>零比特填充：用于同步传输。</p><p>在发送端，只要发现有 5 个连续 1，则立即填入一个 0。接收端对帧中的比特流进行扫描。每当发现 5 个连续1时，就把这 5 个连续 1 后的一个 0 删除，</p><p><a href="/pic/network/3-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-8.png" class="lazyload"></a></p><p>PPP 协议之所以<strong>不使用序号和确认机制</strong>是出于以下的考虑：</p><ol><li>在数据链路层出现差错的概率不大时，使用比较简单的 PPP 协议较为合理。</li><li>在因特网环境下，PPP 的信息字段放入的数据是 IP 数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li><li>帧检验序列 FCS 字段可保证无差错接受。</li></ol><h3 id="33-ppp-协议的工作状态"><a class="markdownIt-Anchor" href="#33-ppp-协议的工作状态"></a> 3.3 PPP 协议的工作状态</h3><p><a href="/pic/network/3-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-9.png" class="lazyload"></a></p><p><strong>整体的工作流程</strong>：</p><ol><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的链路控制协议 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，和进行网络层配置，网络控制协议 NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ol><h2 id="4-使用广播信道的数据链路层"><a class="markdownIt-Anchor" href="#4-使用广播信道的数据链路层"></a> 4 使用广播信道的数据链路层</h2><h3 id="41-局域网的数据链路层"><a class="markdownIt-Anchor" href="#41-局域网的数据链路层"></a> 4.1 局域网的数据链路层</h3><p>局域网最主要的特点是：网络为一个单位所拥有，且地理范围和站点数目均有限。</p><p>局域网具有如下的一些主要优点：</p><ol><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ol><p><a href="/pic/network/3-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-10.png" class="lazyload"></a></p><p><strong>以太网的两个标准</strong>：</p><ol><li>DIX Ethernet V2 是世界上第一个局域网产品（以太网）的规约。</li><li>IEEE 的 802.3 标准。</li></ol><p>注意：DIX Ethernet V2 标准与 IEEE 的 802.3 标准只有很小的差别，因此可以将 802.3 局域网简称为“以太网”。严格说来，“以太网”应当是指符合 DIX Ethernet V2 标准的局域网</p><p><strong>数据链路层的两个子层</strong>（为了使数据链路层能更好地适应多种局域网标准，802 委员会就将局域网的数据链路层拆成两个子层）：</p><ul><li>逻辑链路控制 LLC (Logical Link Control)子层</li><li>媒体接入控制 MAC (Medium Access Control)子层。</li></ul><p>其中与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的。</p><p><a href="/pic/network/3-11.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-11.png" class="lazyload"></a></p><p>以后一般不考虑 LLC 子层，由于 TCP/IP 体系经常使用的局域网是 DIX Ethernet V2 而不是 802.3 标准中的几种局域网，因此现在 802 委员会制定的逻辑链路控制子层 LLC（即 802.2 标准）的作用已经不大了。很多厂商生产的适配器上就仅装有 MAC 协议而没有 LLC 协议。</p><p><strong>适配器(网卡)</strong></p><p>适配器的重要功能：计算机通过适配器和局域网进行通信。</p><ol><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。</li></ol><p><a href="/pic/network/3-12.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-12.png" class="lazyload"></a></p><h3 id="42-csmacd-协议"><a class="markdownIt-Anchor" href="#42-csmacd-协议"></a> 4.2 CSMA/CD 协议</h3><p>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><p><a href="/pic/network/3-13.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-13.png" class="lazyload"></a></p><ol><li>总线上的每一个工作的计算机都能检测到 B 发送的数据信号。</li><li>由于只有计算机 D 的地址与数据帧首部写入的地址一致，因此只有 D 才接收这个数据帧。</li><li>其他所有的计算机（A, C 和 E）都检测到不是发送给它们的数据帧，因此就丢弃这个数据帧而不能够收下来。</li><li>具有广播特性的总线上实现了一对一的通信。</li></ol><p>为了通信的简便，以太网采取了两种重要的措施：</p><ol><li>采用较为灵活的<strong>无连接</strong>的工作方式，即不必先建立连接就可以直接发送数据。</li><li>以太网对发送的数据帧<strong>不进行编号</strong>，也<strong>不要求对方发回确认</strong>。这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。</li></ol><p><strong>以太网提供的服务</strong>：以太网提供的服务是<strong>不可靠的交付</strong>，即尽最大努力的交付。当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做，差错的纠正由高层来决定。如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</p><p>以太网发送的数据都使用曼彻斯特(Manchester)编码。</p><p><a href="/pic/network/3-14.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-14.png" class="lazyload"></a></p><p><strong>载波监听多点接入/碰撞检测 CSMA/CD</strong></p><ul><li><strong>多点接入</strong>：表示许多计算机以多点接入的方式连接在一根总线上。</li><li><strong>载波监听</strong>：指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</li><li><strong>碰撞检测</strong>：就是计算机边发送数据边检测信道上的信号电压大小。当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞；<br>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</li></ul><p><strong>电磁波在总线上的有限传播速率的影响</strong></p><p>当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A 向 B 发出的信息，要经过一定的时间后才能传送到 B。B 若在 A 发送的信息到达 B 之前发送自己的帧(因为这时 B 的载波监听检测不到 A 所发送的信息)，则必然要在某个时间和 A 发送的帧发生碰撞。碰撞的结果是两个帧都变得无用。</p><p><a href="/pic/network/3-15.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-15.png" class="lazyload"></a></p><p><strong>重要特性</strong>：使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行半双工通信。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p><p><strong>争用期</strong>：最先发送数据帧的站，在发送数据帧后至多经过时间 2<em>t</em> （两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2<em>t</em> 称为争用期或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</p><p><strong>争用期的长度</strong>：以太网取 51.2 ms 为争用期的长度。对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突。</p><p><strong>二进制指数类型退避算法</strong>：发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ol><li>确定基本退避时间，一般是取为争用期 2<em>t</em>。</li><li>定义重传次数 <em>k</em> ，<em>k</em>  ≤ 10，即<em>k</em> = Min[重传次数, 10]</li><li>从整数集合[0,1,…, (2<sup><em>k</em></sup> -1)]中随机地取出一个数记为 <em>r</em>。重传所需的时延就是 <em>r</em> 倍的基本退避时间。</li><li>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。</li></ol><p><strong>最短有效帧长</strong>：如果发生冲突，就一定是在发送的前 64 字节之内。由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p><p><strong>强化碰撞</strong>：当发送数据的站一旦发现发生了碰撞时：</p><ol><li>立即停止发送数据；</li><li>再继续发送若干比特的人为干扰信号(jamming signal)，以便让所有用户都知道现在已经发生了碰撞。</li></ol><p><a href="/pic/network/3-16.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-16.png" class="lazyload"></a></p><h2 id="5-使用广播信道的以太网"><a class="markdownIt-Anchor" href="#5-使用广播信道的以太网"></a> 5 使用广播信道的以太网</h2><h3 id="51-使用集线器的星形拓扑"><a class="markdownIt-Anchor" href="#51-使用集线器的星形拓扑"></a> 5.1 使用集线器的星形拓扑</h3><p>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的<strong>双绞线</strong>。这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong>(hub)</p><p>不用电缆而使用无屏蔽双绞线。每个站需要用两对双绞线，分别用于发送和接收。集线器使用了大规模集成电路芯片，因此这样的硬件设备的可靠性已大大提高了。</p><p><strong>以太网在局域网中的统治地位</strong></p><ul><li>星型网 10BASE-T 的通信距离稍短，每个站到集线器的距离不超过 100 m。</li><li>这种 10 Mb/s 速率的无屏蔽双绞线星形网的出现，既降低了成本，又提高了可靠性。</li><li>10BASE-T 双绞线以太网的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。</li></ul><p><strong>集线器的特点</strong></p><p>集线器是使用电子器件来模拟实际电缆线的工作，因此整个系统仍然像一个传统的以太网那样运行。</p><p>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是 CSMA/CD 协议，并共享逻辑上的总线。</p><p>集线器很像一个多接口的转发器，工作在物理层。</p><p><a href="/pic/network/3-17.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-17.png" class="lazyload"></a></p><h3 id="52-以太网的信道利用率"><a class="markdownIt-Anchor" href="#52-以太网的信道利用率"></a> 5.2 以太网的信道利用率</h3><p><a href="/pic/network/3-18.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-18.png" class="lazyload"></a></p><p>以太网的信道被占用的情况：</p><ol><li>争用期长度为 2<em>t</em>，即端到端传播时延的两倍。检测到碰撞后不发送干扰信号。</li><li>帧长为 <em>L</em> (bit)，数据发送速率为 <em>C</em> (b/s)，因而帧的发送时间为 <em>L</em>/<em>C</em> = <em>T</em><sub>0</sub> (s)。</li></ol><p>一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间 <em>t</em> 使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。</p><p><strong>参数 <em>a</em></strong></p><p>要提高以太网的信道利用率，就必须减小 <em>t</em> 与 <em>T</em><sub>0</sub> 之比。在以太网中定义了参数 <em>a</em>，它是以太网单程端到端时延 <em>t</em> 与帧的发送时间 <em>T</em><sub>0</sub> 之比：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mfrac><mi>τ</mi><msub><mi>T</mi><mn>0</mn></msub></mfrac></mrow><annotation encoding="application/x-tex">a=\frac{\tau }{T_{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.9435600000000002em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><ul><li><p><em>a</em>→0 表示一发生碰撞就立即可以检测出来，并立即停止发送，因而信道利用率很高。</p></li><li><p><em>a</em> 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</p></li><li><p>当数据率一定时，以太网的连线的长度受到限制，否则 <em>t</em> 的数值会太大。</p></li><li><p>以太网的帧长不能太短，否则 <em>T</em><sub>0</sub> 的值会太小，使 <em>a</em> 值太大。</p></li></ul><p><strong>信道利用率的最大值 <em>S</em><sub>max</sub></strong></p><p>在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是 CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。</p><p>发送一帧占用线路的时间是 <em>T</em><sub>0</sub> + <em>t</em>，而帧本身的发送时间是 <em>T</em><sub>0</sub>。于是我们可计算出理想情况下的极限信道利用率 <em>S</em><sub>max</sub>为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub><mo>=</mo><mfrac><msub><mi>T</mi><mn>0</mn></msub><mrow><msub><mi>T</mi><mn>0</mn></msub><mo>+</mo><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>+</mo><mi>a</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">S_{max}=\frac{T_{0}}{T_{0}+t}=\frac{1}{1+a}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">t</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">a</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><h2 id="6-以太网的-mac-层"><a class="markdownIt-Anchor" href="#6-以太网的-mac-层"></a> 6 以太网的 MAC 层</h2><h3 id="61-mac-层的硬件地址"><a class="markdownIt-Anchor" href="#61-mac-层的硬件地址"></a> 6.1 MAC 层的硬件地址</h3><p>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</p><p>IEEE 的注册管理机构 RA 负责向厂家分配地址字段的前三个字节(即高位 24 位)。地址字段中的后三个字节(即低位 24 位)由厂家自行指派，称为扩展标识符，必须保证生产出的适配器没有重复地址。一个地址块可以生成2<sup>24</sup>个不同的地址。这种 48 位地址称为 MAC-48，它的通用名称是EUI-48。“MAC地址”实际上就是适配器地址或适配器标识符EUI-48。</p><p><strong>适配器检查 MAC 地址</strong></p><p>适配器从网络上每收到一个 MAC 帧就首先用硬件检查 MAC 帧中的 MAC 地址。</p><p>如果是发往本站的帧则收下，然后再进行其他的处理；否则就将此帧丢弃，不再进行其他的处理。</p><p>“发往本站的帧”包括以下三种帧： 单播帧（一对一）、广播帧（一对全体）、多播帧（一对多）。</p><h3 id="62-mac-帧的格式"><a class="markdownIt-Anchor" href="#62-mac-帧的格式"></a> 6.2 MAC 帧的格式</h3><p><a href="/pic/network/3-19.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-19.png" class="lazyload"></a></p><ul><li>为了达到比特同步，在传输媒体上实际传送的要比 MAC 帧还多 8 个字节。在帧的前面插入的 8 字节中的第一个字段共 7 个字节，是前同步码，用来迅速实现 MAC 帧的比特同步。第二个字段是帧开始定界符，表示后面的信息就是MAC 帧。</li><li>类型字段用来标志上一层使用的是什么协议，以便把收到的 MAC 帧的数据上交给上一层的这个协议。</li><li>数据字段的正式名称是 MAC 客户数据字段，最小长度 64 字节 - 18 字节的首部和尾部 = 数据字段的最小长度。</li><li>当传输媒体的误码率为 1x10<sup>-8</sup> 时，MAC 子层可使未检测到的差错小于 1x10<sup>-14</sup>。</li><li>当数据字段的长度小于 46 字节时，应在数据字段的后面加入整数字节的填充字段，以保证以太网的 MAC 帧长不小于 64 字节。</li></ul><p><strong>无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li><li>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</li></ul><p><strong>帧间最小间隔</strong></p><p>帧间最小间隔为 9.6 ms，相当于 96 bit 的发送时间。一个站在检测到总线开始空闲后，还要等待 9.6 ms 才能再次发送数据。这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。</p><h2 id="7-扩展的局域网"><a class="markdownIt-Anchor" href="#7-扩展的局域网"></a> 7 扩展的局域网</h2><h3 id="71-在物理层扩展局域网"><a class="markdownIt-Anchor" href="#71-在物理层扩展局域网"></a> 7.1 在物理层扩展局域网</h3><p>用多个集线器可连成更大的局域网，且用集线器组成更大的局域网都在一个碰撞域中。</p><p>碰撞域：在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p><a href="/pic/network/3-20.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-20.png" class="lazyload"></a></p><p><strong>用集线器扩展局域网的优缺点</strong></p><p>优点：使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信；扩大了局域网覆盖的地理范围。</p><p>缺点：碰撞域增大了，但总的吞吐量并未提高；如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</p><h3 id="72-在数据链路层扩展局域网"><a class="markdownIt-Anchor" href="#72-在数据链路层扩展局域网"></a> 7.2 在数据链路层扩展局域网</h3><p>在数据链路层扩展局域网是使用<strong>网桥</strong>。</p><p>网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。</p><p>网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口。</p><p>网桥使各网段成为隔离开的碰撞域。</p><p><a href="/pic/network/3-21.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-21.png" class="lazyload"></a></p><p>使用网桥带来的好处：</p><ul><li>过滤通信量；</li><li>扩大了物理范围；</li><li>提高了可靠性；</li><li>可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。</li></ul><p>使用网桥带来的缺点：</p><ul><li><p>存储转发增加了时延。</p></li><li><p>在 MAC 子层并没有流量控制功能。</p></li><li><p>具有不同 MAC 子层的网段桥接在一起时时延更大。</p></li><li><p>网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。</p></li></ul><p><a href="/pic/network/3-22.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-22.png" class="lazyload"></a></p><p>网桥和集线器的不同：集线器在转发帧时，不对传输媒体进行检测；网桥在转发帧之前必须执行 CSMA/CD 算法，若在发送过程中出现碰撞，就必须停止发送和进行退避。</p><p><strong>透明网桥</strong></p><p>目前使用得最多的网桥是透明网桥(transparent bridge)。</p><p>“透明”是指局域网上的站点并不知道所发送的帧将经过哪几个网桥，因为网桥对各站来说是看不见的。</p><p>透明网桥是一种即插即用设备，其标准是 IEEE 802.1D。</p><p><strong>网桥应当按照以下自学习算法处理收到的帧和建立转发表</strong></p><ol><li>若从 A 发出的帧从接口 x 进入了某网桥，那么从这个接口出发沿相反方向一定可把一个帧传送到 A。</li><li>网桥每收到一个帧，就记下其源地址和进入网桥的接口，作为转发表中的一个项目。</li><li>在建立转发表时是把帧首部中的源地址写在“地址”这一栏的下面。</li><li>在转发帧时，则是根据收到的帧首部中的目的地址来转发的。这时就把在“地址”栏下面已经记下的源地址当作目的地址，而把记下的进入接口当作转发接口。</li></ol><p><a href="/pic/network/3-23.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-23.png" class="lazyload"></a></p><p>网桥在转发表中登记以下三个信息：除了<strong>地址</strong>和<strong>接口</strong>外，还有<strong>帧进入该网桥的时间</strong>。</p><p>这是因为以太网的拓扑可能经常会发生变化，站点也可能会更换适配器（这就改变了站点的地址）。另外，以太网上的工作站并非总是接通电源的。把每个帧到达网桥的时间登记下来，就可以在转发表中只保留网络拓扑的最新状态信息。这样就使得网桥中的转发表能反映当前网络的最新拓扑状态。</p><p><strong>网桥的自学习和转发帧的步骤归纳</strong></p><ol><li>网桥收到一帧后先进行自学习。查找转发表中与收到帧的源地址有无相匹配的项目。如没有，就在转发表中增加一个项目（源地址、进入的接口和时间）。如有，则把原有的项目进行更新。</li><li>转发帧。查找转发表中与收到帧的目的地址有无相匹配的项目。<ol><li>如没有，则通过所有其他接口（但进入网桥的接口除外）按进行转发。</li><li>如有，则按转发表中给出的接口进行转发。</li><li>若转发表中给出的接口就是该帧进入网桥的接口，则应丢弃这个帧（因为这时不需要经过网桥进行转发）。</li></ol></li></ol><p><strong>透明网桥使用了生成树算法</strong></p><p>这是为了避免产生转发的帧在网络中不断地兜圈子。</p><p><a href="/pic/network/3-24.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-24.png" class="lazyload"></a></p><p>互连在一起的网桥在进行彼此通信后，就能找出原来的网络拓扑的一个子集。在这个子集里，整个连通的网络中不存在回路，即在任何两个站之间只有一条路径。为了避免产生转发的帧在网络中不断地兜圈子。为了得出能够反映网络拓扑发生变化时的生成树，在生成树上的根网桥每隔一段时间还要对生成树的拓扑进行更新。</p><p><strong>源路由网桥</strong></p><p>透明网桥容易安装，但网络资源的利用不充分。源路由(source route)网桥在发送帧时将详细的路由信息放在帧的首部中。源站以广播方式向欲通信的目的站发送一个发现帧，每个发现帧都记录所经过的路由。发现帧到达目的站时就沿各自的路由返回源站。源站在得知这些路由后，从所有可能的路由中选择出一个最佳路由。凡从该源站向该目的站发送的帧的首部，都必须携带源站所确定的这一路由信息。</p><p><strong>多接口网桥——以太网交换机</strong></p><p>1990 年问世的交换式集线器(switching hub)，可明显地提高局域网的性能。交换式集线器常称为<strong>以太网交换机</strong>(switch)或第二层交换机（表明此交换机工作在数据链路层）。以太网交换机通常都有十几个接口，因此，以太网交换机实质上就是一个<strong>多接口的网桥</strong>，可见交换机工作在数据链路层。</p><p>以太网交换机的特点：</p><ul><li>以太网交换机的每个接口都直接与主机相连，并且一般都工作在<strong>全双工方式</strong>。</li><li>交换机能同时连通许多对的接口，使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。</li><li>以太网交换机由于使用了专用的交换结构芯片，其交换速率就较高。</li></ul><p>用以太网交换机扩展局域网</p><p><a href="/pic/network/3-25.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-25.png" class="lazyload"></a></p><p>利用以太网交换机可以很方便地实现<strong>虚拟局域网</strong>。</p><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组。这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的工作站是属于哪一个 VLAN。虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网</p><p><a href="/pic/network/3-26.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/3-26.png" class="lazyload"></a></p><p>虚拟局域网协议允许在以太网的帧格式中插入一个 4 字节的标识符，称为 VLAN 标记(tag)，用来指明发送该帧的工作站属于哪一个虚拟局域网。</p><p>虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息(即“广播风暴”)而引起性能恶化。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(二)：物理层</title>
      <link href="/2020/01/28/network-2/"/>
      <url>/2020/01/28/network-2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-物理层的基本概念"><a class="markdownIt-Anchor" href="#1-物理层的基本概念"></a> 1 物理层的基本概念</h2><p>物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：</p><ul><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。</li><li><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li></ul><h2 id="2-数据通信的基础知识"><a class="markdownIt-Anchor" href="#2-数据通信的基础知识"></a> 2 数据通信的基础知识</h2><h3 id="21-数据通信系统的模型"><a class="markdownIt-Anchor" href="#21-数据通信系统的模型"></a> 2.1 数据通信系统的模型</h3><p><a href="/pic/network/2-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-1.png" class="lazyload"></a></p><p>相关的术语：</p><ul><li><strong>数据</strong>(data)——运送消息的实体。</li><li><strong>信号</strong>(signal)——数据的电气的或电磁的表现。</li><li>“<strong>模拟的</strong>”(analogous)——代表消息的参数的取值是连续的。</li><li>“<strong>数字的</strong>”(digital)——代表消息的参数的取值是离散的。</li><li><strong>码元</strong>(code)——在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</li></ul><h3 id="22-有关信号的几个基本概念"><a class="markdownIt-Anchor" href="#22-有关信号的几个基本概念"></a> 2.2 有关信号的几个基本概念</h3><p>（1）数据传输方式：</p><ul><li><strong>单向通信</strong>（单工通信）——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信</strong>（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信</strong>（全双工通信）——通信的双方可以同时发送和接收信息。</li></ul><p>（2）信号种类：</p><ul><li><strong>基带信号</strong>（基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</li><li><strong>带通信号</strong>——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li></ul><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制(modulation)。</p><p>（3）调制方法</p><ul><li><strong>调幅</strong>(AM)：载波的<strong>振幅</strong>随基带数字信号而变化。</li><li><strong>调频</strong>(FM)：载波的<strong>频率</strong>随基带数字信号而变化。</li><li><strong>调相</strong>(PM) ：载波的<strong>初始相位</strong>随基带数字信号而变化。</li></ul><p><a href="/pic/network/2-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-2.png" class="lazyload"></a></p><h3 id="23-信道的极限容量"><a class="markdownIt-Anchor" href="#23-信道的极限容量"></a> 2.3 信道的极限容量</h3><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p><p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</p><p><strong>奈氏准则</strong>：在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p><ol><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。</li></ol><p><strong>香农公式</strong>：表示带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（b/s）。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>=</mo><mi>W</mi><msup><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub></mrow><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy="false">)</mo></mrow></msup></mrow><annotation encoding="application/x-tex">C=W{log_{2}}^{(1+\frac{S}{N})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2522449999999998em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.0578049999999999em;"><span style="top:-3.44734em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8720928571428572em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>其中<em>W</em> 为信道的带宽（以 Hz 为单位），<em>S</em> 为信道内所传信号的平均功率，<em>N</em> 为信道内部的高斯噪声功率。</p><ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li><li>若信道带宽 <em>W</em> 或信噪比 <em>S</em>/<em>N</em> 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 <em>C</em> 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是用<strong>编码</strong>的方法让每一个码元携带更多比特的信息量。</li></ul><h2 id="3-物理层下面的传输媒体"><a class="markdownIt-Anchor" href="#3-物理层下面的传输媒体"></a> 3 物理层下面的传输媒体</h2><p><a href="/pic/network/2-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-3.png" class="lazyload"></a></p><ul><li>导向传输媒体：双绞线、同轴电缆、光缆；</li><li>非导向传输媒体：无线传输、短波通信、微波；</li></ul><h2 id="4-信道复用技术"><a class="markdownIt-Anchor" href="#4-信道复用技术"></a> 4 信道复用技术</h2><p>复用(multiplexing)是通信技术中的基本概念。</p><p><a href="/pic/network/2-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-4.png" class="lazyload"></a></p><h3 id="41-频分复用-fdm"><a class="markdownIt-Anchor" href="#41-频分复用-fdm"></a> 4.1 频分复用 FDM</h3><p><a href="/pic/network/2-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-5.png" class="lazyload"></a></p><p>用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p><p>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p><h3 id="42-时分复用-tdm"><a class="markdownIt-Anchor" href="#42-时分复用-tdm"></a> 4.2 时分复用 TDM</h3><p><a href="/pic/network/2-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-6.png" class="lazyload"></a></p><p>时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧），每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</p><p>每一个用户所占用的时隙是周期性地出现（其周期就是 TDM 帧的长度）。</p><p>TDM 信号也称为等时(isochronous)信号。</p><p>时分复用的所有用户是在不同的时间占用同样的频带宽度。</p><p><a href="/pic/network/2-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-7.png" class="lazyload"></a></p><p>时分复用可能会造成线路资源的浪费，使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</p><h3 id="43-统计时分复用-stdm"><a class="markdownIt-Anchor" href="#43-统计时分复用-stdm"></a> 4.3 统计时分复用 STDM</h3><p><a href="/pic/network/2-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-8.png" class="lazyload"></a></p><p>把公共信道的时隙实行“按需分配”，即只对那些需要传送信息或正在工作的终端才分配给时隙，这样就使所有的时隙都能饱满地得到使用，可以使服务的终端数大于时隙的个数，提高了媒质的利用率，从而起到了“复用”的作用。</p><h3 id="44-波分复用-wdm"><a class="markdownIt-Anchor" href="#44-波分复用-wdm"></a> 4.4 波分复用 WDM</h3><p><a href="/pic/network/2-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-9.png" class="lazyload"></a></p><p>波分复用就是光的频分复用。</p><h3 id="45-码分复用-cdm"><a class="markdownIt-Anchor" href="#45-码分复用-cdm"></a> 4.5 码分复用 CDM</h3><p>常用的名词是<strong>码分多址</strong>CDMA(Code Division Multiple Access)。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</p><ul><li>每一个比特时间划分为 <em>m</em> 个短的间隔，称为<strong>码片</strong>(chip)。</li><li>每个站被指派一个唯一的 <em>m</em> bit 码片序列。<ul><li>如发送比特 1，则发送自己的 <em>m</em> bit 码片序列。</li><li>如发送比特 0，则发送该码片序列的二进制反码。</li></ul></li><li>每个站分配的码片序列不仅必须各不相同，并且还必须互相<strong>正交</strong>(orthogonal)。两个不同站的码片序列正交，就是向量 S 和 T 的规格化内积(inner product)都是 0：</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⋅</mo><mi>T</mi><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><msub><mi>T</mi><mi>i</mi></msub><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S\cdot T=\frac{1}{m}\sum_{i=1}^{m}S_{i}T_{i}=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><ul><li>任何一个码片向量和该码片向量自己的规格化内积都是1；一个码片向量和该码片反码的向量的规格化内积值是 –1。</li></ul><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⋅</mo><mi>S</mi><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>S</mi><mi>i</mi></msub><msub><mi>S</mi><mi>i</mi></msub><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msubsup><mi>S</mi><mi>i</mi><mn>2</mn></msubsup><mo>=</mo><mfrac><mn>1</mn><mi>m</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><mo stretchy="false">(</mo><mo>±</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S\cdot S=\frac{1}{m}\sum_{i=1}^{m}S_{i}S_{i}=\frac{1}{m}\sum_{i=1}^{m}S_{i}^{2}=\frac{1}{m}\sum_{i=1}^{m}(\pm 1)^{2}=1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">±</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p><a href="/pic/network/2-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/2-10.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(一)：计算机网络概述</title>
      <link href="/2020/01/21/network-1/"/>
      <url>/2020/01/21/network-1/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络在信息时代中的作用"><a class="markdownIt-Anchor" href="#计算机网络在信息时代中的作用"></a> 计算机网络在信息时代中的作用</h2><p>21世纪的重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。</p><p>网络是指”三网“，即电信网络、有线电视网络和计算机网络。</p><p>计算机网络向用户提供的最重要的功能：</p><ul><li><strong>连通性</strong>：计算机网络使上网用户之间都可以交换信息，好像这些用户的计算机都可以彼此直接连通一样。</li><li><strong>共享性</strong>：即资源共享。可以是信息共享、软件共享，也可以是硬件共享。</li></ul><h2 id="因特网概述"><a class="markdownIt-Anchor" href="#因特网概述"></a> 因特网概述</h2><p>首先区分三个概念：</p><ul><li><strong>网络</strong>(network)：许多计算机连接在一起；</li><li><strong>互联网</strong>(internet)：许多网络连接在一起；</li><li><strong>因特网</strong>(Internet)：全球最大的一个互联网；</li></ul><p><a href="/pic/network/1-1.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-1.png" class="lazyload"></a></p><p>因特网发展的三个阶段：</p><p>第一阶段是从单个网络 ARPANET 向互联网发展的过程。1983 年 TCP/IP 协议成为 ARPANET 上的标准协议，人们把 1983 年作为因特网的诞生时间。</p><p>第二阶段的特点是建成了三级结构的因特网。三级计算机网络分为主干网、地区网和校园网（或企业网）。</p><p>第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。出现了因特网服务提供者 ISP (Internet Service Provider)。 根据提供服务的覆盖面积大小以及所拥有的 IP 地址数目的不同，ISP 也分成为不同的层次。</p><p><a href="/pic/network/1-2.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-2.png" class="lazyload"></a></p><p>制订因特网的正式标准的四个阶段：</p><ol><li>因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。</li><li>建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。</li><li>草案标准(Draft Standard)</li><li>因特网标准(Internet Standard)</li></ol><p><a href="/pic/network/1-3.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-3.png" class="lazyload"></a></p><h2 id="因特网的组成"><a class="markdownIt-Anchor" href="#因特网的组成"></a> 因特网的组成</h2><p>从因特网的工作方式上看，可以划分两部分：</p><ul><li><strong>边缘部分</strong>：由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li><li><strong>核心部分</strong>：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul><p><a href="/pic/network/1-4.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-4.png" class="lazyload"></a></p><h3 id="1-因特网的边缘部分"><a class="markdownIt-Anchor" href="#1-因特网的边缘部分"></a> 1 因特网的边缘部分</h3><p>处在因特网边缘的部分就是连接在因特网上的所有的主机，这些主机又称为端系统(end system)。</p><p>在网络边缘的端系统中运行的程序之间的通信方式通常可划分为两大类：</p><ul><li><strong>客户服务器方式</strong>（C/S 方式），即Client/Server方式</li><li><strong>对等方式</strong>（P2P 方式），即 Peer-to-Peer方式</li></ul><p><a href="/pic/network/1-5.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-5.png" class="lazyload"></a></p><p><strong>客户服务器方式</strong></p><p>客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。客户服务器方式所描述的是进程之间服务和被服务的关系。客户是服务的请求方，服务器是服务的提供方。</p><p><strong>客户软件</strong>的特点：被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务），因此客户程序必须知道服务器程序的地址；不需要特殊的硬件和很复杂的操作系统。</p><p><strong>服务器软件</strong>的特点：一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求；系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求，因此服务器程序不需要知道客户程序的地址；一般需要强大的硬件和高级的操作系统支持。</p><p><strong>对等连接方式</strong></p><p>对等连接(peer-to-peer，简写为P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。双方都可以下载对方已经存储在硬盘中的共享文档。</p><p><strong>对等连接方式的特点</strong>：对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F 提供服务，那么 C 又同时起着服务器的作用。</p><h3 id="2-因特网的核心部分"><a class="markdownIt-Anchor" href="#2-因特网的核心部分"></a> 2 因特网的核心部分</h3><p>网络核心部分是因特网中最复杂的部分，网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是路由器(router)。路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><p><strong>数据交换方式</strong></p><p><strong>(一) 电路交换(Circuit Switching)</strong></p><p>最主要的应用就是电话网络，电路交换必定是面向连接的；电路交换适合于数据量很大的实时性传输；核心路由器之间可以使用电路交换。</p><p>电路交换的三个阶段：</p><ol><li>建立连接（申请占用通信资源）</li><li>通信（一直占用通信资源）</li><li>释放连接（释放通信资源）</li></ol><p>为什么不能用电路交换方式传输计算机的数据？</p><p>计算机数据具有突发性，这导致通信线路的利用率很低。</p><p><strong>(二) 报文交换(Message Switching)</strong></p><p>在 20 世纪 40 年代，电报通信也采用了基于存储转发原理的报文交换(message switching)。 报文交换的时延较长，从几分钟到几小时不等。现在报文交换已经很少有人使用了。</p><p>报文交换的特点：</p><ul><li>报文一般比分组长的多</li><li>报文交换的时延较长</li></ul><p><strong>(三) 分组交换(Packet Switching)</strong></p><p><strong>分组交换的过程</strong>：</p><ol><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段。</li><li>每一个数据段前面添加上首部构成分组。</li><li>分组交换网以“分组”作为数据传输单元，依次把各分组发送到接收端。</li><li>接收端收到分组后剥去首部还原成报文。</li><li>最后，在接收端把收到的数据恢复成为原来的报文。</li></ol><p><strong>分组首部的重要性</strong></p><ul><li>每一个分组的首部都含有地址等控制信息。</li><li>分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。</li><li>用这样的存储转发方式，最后分组就能到达最终目的地。</li></ul><p><strong>路由器的存储转发</strong></p><p>在路由器中的输入和输出端口之间没有直接连线，路由器处理分组的过程是：</p><ol><li>把收到的分组先放入缓存（暂时存储）；</li><li>查找转发表，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口转发出去。</li></ol><p><a href="/pic/network/1-6.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-6.png" class="lazyload"></a></p><p><strong>主机和路由器的作用不同</strong></p><ul><li>主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组。</li><li>路由器对分组进行存储转发，最后把分组交付目的主机。</li></ul><p>分组交换的优点</p><ul><li><strong>高效</strong>：动态分配传输带宽，对通信链路是逐段占用。</li><li><strong>灵活</strong>：以分组为传送单位和查找路由。</li><li><strong>迅速</strong>：不必先建立连接就能向其他主机发送分组。</li><li><strong>可靠</strong>：保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。</li></ul><p>分组交换的缺点</p><ul><li><strong>时延</strong>：分组在各结点存储转发时需要排队，这就会造成一定的时延。</li><li><strong>开销</strong>：分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。</li></ul><p><strong>三种交换方式的比较</strong></p><p><a href="/pic/network/1-7.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-7.png" class="lazyload"></a></p><p><strong>总结</strong>：</p><ul><li>因特网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在因特网的边缘部分。</li><li>在因特网核心部分的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。</li><li>主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。</li></ul><p><strong>计算机网络的发展</strong></p><p><a href="/pic/network/1-8.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-8.png" class="lazyload"></a></p><ul><li>早期的面向终端的计算机网络是以单个主机为中心的星形网，各终端通过通信线路共享昂贵的中心主机的硬件和软件资源。</li><li>分组交换网则是以网络为中心，主机都处在网络的外围，用户通过分组交换网可共享连接在网络上的许多硬件和各种丰富的软件资源。</li></ul><p>新型网络的特点：</p><ul><li>网络用于计算机之间的数据传送，而不是为了打电话。</li><li>网络能够连接不同类型的计算机，不局限于单一类型的计算机。</li><li>所有的网络结点都同等重要，因而大大提高网络的生存性。</li><li>计算机在进行通信时，必须有冗余的路由。</li><li>网络的结构应当尽可能地简单，同时还能够非常可靠地传送数据。</li></ul><h2 id="计算机网络的分类"><a class="markdownIt-Anchor" href="#计算机网络的分类"></a> 计算机网络的分类</h2><p>从不同维度上可以对网络进行不同的划分：</p><ul><li>按照作用范围：广域网、城域网、局域网、个人区域网；</li><li>按照使用者：公用网、专用网；</li><li>按照拓扑结构：总线型、环型、星型、树型、网状；</li><li>按照交换方式：电路交换网、报文交换网、分组交换网；</li><li>按照工作方式：资源子网、通信子网、接入网；</li></ul><h2 id="计算机网络的性能"><a class="markdownIt-Anchor" href="#计算机网络的性能"></a> 计算机网络的性能</h2><p><strong>1. 速率</strong></p><p>速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。指连接在计算机网络上的主机在数字信道上传送数据位数的速率。单位是 b/s、kb/s、Mb/s、Gb/s 等，速率往往是指额定速率或标称速率。</p><p><strong>比特</strong>（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。</p><p><strong>2. 带宽</strong></p><p>带宽是数据通信领域中，数字信道所传送的最高数据率。单位是 b/s、kb/s、Mb/s、Gb/s 等。</p><p><strong>3. 吞吐量</strong></p><p>吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络；吞吐量受网络的带宽或网络的额定速率的限制。</p><p><strong>4. 时延</strong></p><p><strong>传输时延</strong>（发送时延）：发送数据时，数据块从结点进入到传输媒体所需要的时间。</p><p>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">发</mi><mi mathvariant="normal">送</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">数</mi><mi mathvariant="normal">据</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">）</mi></mrow><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">带</mi><mi mathvariant="normal">宽</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">比</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">秒</mi><mi mathvariant="normal">）</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">发送时延 = \frac{数据块长度（比特）}{信道带宽（比特/秒）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">宽</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">特</span><span class="mord">/</span><span class="mord cjk_fallback">秒</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">据</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">比</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>传播时延</strong>：电磁波在信道中需要传播一定的距离而花费的时间。</p><p>信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">传</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>=</mo><mfrac><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">长</mi><mi mathvariant="normal">度</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">米</mi><mi mathvariant="normal">）</mi></mrow><mrow><mi mathvariant="normal">信</mi><mi mathvariant="normal">号</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">道</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">传</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">速</mi><mi mathvariant="normal">率</mi><mi mathvariant="normal">（</mi><mi mathvariant="normal">米</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">秒</mi><mi mathvariant="normal">）</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">传播时延 = \frac{信道长度（米）}{信号在信道上的传播速率（米/秒）}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.613em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.677em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">号</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">速</span><span class="mord cjk_fallback">率</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">米</span><span class="mord">/</span><span class="mord cjk_fallback">秒</span><span class="mord cjk_fallback">）</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">道</span><span class="mord cjk_fallback">长</span><span class="mord cjk_fallback">度</span><span class="mord cjk_fallback">（</span><span class="mord cjk_fallback">米</span><span class="mord cjk_fallback">）</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p><strong>处理时延</strong>：交换结点为存储转发而进行一些必要的处理所花费的时间。</p><p><strong>排队时延</strong>：结点缓存队列中分组排队所经历的时延，排队时延的长短往往取决于网络中当时的通信量。</p><p>数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">总</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>=</mo><mi mathvariant="normal">发</mi><mi mathvariant="normal">送</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>+</mo><mi mathvariant="normal">传</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>+</mo><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>+</mo><mi mathvariant="normal">处</mi><mi mathvariant="normal">理</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi></mrow><annotation encoding="application/x-tex">总时延 = 发送时延+传播时延+处理时延+处理时延</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">发</span><span class="mord cjk_fallback">送</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">处</span><span class="mord cjk_fallback">理</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span></span></span></span></span></p><p><a href="/pic/network/1-9.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-9.png" class="lazyload"></a></p><p>注意：</p><ul><li>对于高速网络链路，我们提高的仅仅是数据的发送速率而不是比特在链路上的传播速率。</li><li>提高链路带宽减小了数据的发送时延。</li></ul><p><strong>5. 时延带宽积</strong></p><p>链路的时延带宽积又称为以比特为单位的链路长度，表示在特定时间该网络上的最大数据量——已发送但尚未确认的数据。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mi mathvariant="normal">带</mi><mi mathvariant="normal">宽</mi><mi mathvariant="normal">积</mi><mo>=</mo><mi mathvariant="normal">传</mi><mi mathvariant="normal">播</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">延</mi><mo>×</mo><mi mathvariant="normal">带</mi><mi mathvariant="normal">宽</mi></mrow><annotation encoding="application/x-tex">时延带宽积 = 传播时延 \times 带宽</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">宽</span><span class="mord cjk_fallback">积</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord cjk_fallback">传</span><span class="mord cjk_fallback">播</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">延</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">带</span><span class="mord cjk_fallback">宽</span></span></span></span></span></p><p><strong>6. 往返时间</strong></p><p>往返时间RTT（Round-Trip Time）表示从发送方发送数据开始，到发送方收到接收方确认的时间间隔。（Ping命令的时间）</p><p><strong>7. 利用率</strong></p><ul><li>信道利用率：指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。信道利用率并非越高越好。</li><li>网络利用率：是全网络的信道利用率的加权平均值。</li></ul><p>时延与网络利用率的关系：</p><p>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p><p>若令 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示网络空闲时的时延，<em>D</em> 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 <em>D</em> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>D</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">D_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>之间的关系：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><msub><mi>D</mi><mn>0</mn></msub><mrow><mn>1</mn><mo>−</mo><mi>U</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">D=\frac{D_0}{1-U}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.1296600000000003em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>U 是网络的利用率，数值在 0 到 1 之间。</p><p><a href="/pic/network/1-10.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-10.png" class="lazyload"></a></p><h2 id="计算机网络的体系结构"><a class="markdownIt-Anchor" href="#计算机网络的体系结构"></a> 计算机网络的体系结构</h2><p>计算机网络的<strong>体系结构</strong>(architecture)是计算机网络的各层及其协议的集合。 体系结构就是这个计算机网络及其部件所应完成的功能的<strong>精确定义</strong>。<strong>实现</strong>(implementation)是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</p><p><strong>计算机网络分层的好处</strong>：各层之间是独立的；灵活性好；结构上可分割开；易于实现和维护；能促进标准化工作。</p><p>层数多少要适当：若层数太少，就会使每一层的协议太复杂；层数太多又会在描述和综合各层功能的系统工程任务时遇到较多的困难。</p><p><a href="/pic/network/1-11.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-11.png" class="lazyload"></a></p><h3 id="osi-参考模型"><a class="markdownIt-Anchor" href="#osi-参考模型"></a> OSI 参考模型</h3><ul><li><strong>应用层</strong>：能够产生网络流量，能够和用户交互的应用程序。</li><li><strong>表示层</strong>：在数据传输之前进行的加密、压缩等处理。</li><li><strong>会话层</strong>：服务器和客户端建立的会话连接（可以通过 netstat -n 查看会话）。</li><li><strong>传输层</strong>：可以进行可靠传输、不可靠传输以及流量传输。</li><li><strong>网络层</strong>：负责选择最佳路径，进行IP地址编址（ ipv4和ipv6变化只会影响网络层 ）。</li><li><strong>数据链路层</strong>：负责数据的封装，帧的开始和结束、透明传输、差错校验（纠错由传输层解决）</li><li><strong>物理层</strong>：定义网络设备接口标准，电气标准(电压)，如何在物理链路上传输的更快。</li></ul><p>OSI参考模型对网络排错的意义：</p><p>每一层都为上一层提供服务，一旦某一层崩了，上面所有层都崩了，所以排查问题从最上层（物理层）排查。</p><ol><li>物理层故障怎么办？查看链接状态，发送和接收的数据包数值；</li><li>数据链路层故障怎么办？Mac地址冲突，2个一样的Mac地址同时访问；ADSL(非对称数字用户线路)欠费；两端的接口网速没有协商一致；计算机连接到其它VLAN(虚拟互联网)中；</li><li>网络层故障怎么办？配置错误的IP地址，子网掩码，网关；数据有没有通过各个网关到达指定位置；</li><li>应用层(合并3层)故障怎么办？应用程序配置问题；</li></ol><p>OSI参考模型和网络安全解决办法：</p><ol><li>物理层安全隐患？别人能私自接入你的网络，应该拔掉不用的网线或接口；</li><li>数据链路层安全隐患？ADSL账号密码，VLAN，交换机端口绑定Mac地址；</li><li>网络层安全隐患？路由器上使用ACL(访问控制列表)控制数据包流量；防火墙设置；</li><li>应用层安全隐患？应用程序有没有漏洞；</li></ol><p>开发系统信息交换涉及到的概念：</p><ul><li>实体：交换信息的硬件或软件进程；</li><li>协议：控制两个对等实体通信的规则；</li><li>服务：下层向上层提供服务，上层需要使用下层提供的服务来实现本层的功能；</li><li>服务访问点SAP：相邻两层实体间交换信息的地方；</li></ul><p><a href="/pic/network/1-12.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-12.png" class="lazyload"></a></p><p>需要注意的是：</p><ol><li>本层的服务用户只能看见服务而无法看见下面的协议。</li><li>下面的协议对上面的服务用户是透明的。</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li><li>服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。</li></ol><p><strong>数据的传输过程</strong></p><p><a href="/pic/network/1-13.png" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/pic/network/1-13.png" class="lazyload"></a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
