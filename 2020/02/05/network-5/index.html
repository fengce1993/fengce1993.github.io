<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>计算机网络(六)：运输层 | BLEACH</title><meta name="description" content="计算机网络(六)：运输层"><meta name="keywords" content="计算机网络"><meta name="author" content="fc"><meta name="copyright" content="fc"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="计算机网络(六)：运输层"><meta name="twitter:description" content="计算机网络(六)：运输层"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta property="og:type" content="article"><meta property="og:title" content="计算机网络(六)：运输层"><meta property="og:url" content="http://fengce1993.github.io/2020/02/05/network-5/"><meta property="og:site_name" content="BLEACH"><meta property="og:description" content="计算机网络(六)：运输层"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://fengce1993.github.io/2020/02/05/network-5/"><link rel="prev" title="计算机网络(气)：应用层" href="http://fengce1993.github.io/2020/02/06/network-6/"><link rel="next" title="计算机网络(五)：网络层(二)" href="http://fengce1993.github.io/2020/02/03/network-4-2/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">BLEACH</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">1</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-运输层协议概述"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text"> 1 运输层协议概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-进程之间的通信"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text"> 1.1 进程之间的通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#12-运输层的两个主要协议"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text"> 1.2 运输层的两个主要协议</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#13-运输层的端口"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text"> 1.3 运输层的端口</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-用户数据报协议-udp"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text"> 2 用户数据报协议 UDP</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#21-udp-概述"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text"> 2.1 UDP 概述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#22-udp-的首部格式"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text"> 2.2 UDP 的首部格式</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-传输控制协议-tcp-概述"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text"> 3 传输控制协议 TCP 概述</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#31-tcp-最主要的特点"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text"> 3.1 TCP 最主要的特点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#32-tcp-的连接"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text"> 3.2 TCP 的连接</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-可靠传输的工作原理"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text"> 4 可靠传输的工作原理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#41-停止等待协议"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text"> 4.1 停止等待协议</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#42-连续-arq-协议"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text"> 4.2 连续 ARQ 协议</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5-tcp-报文段的首部格式"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text"> 5 TCP 报文段的首部格式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6-tcp-可靠传输的实现"><span class="toc_mobile_items-number">6.</span> <span class="toc_mobile_items-text"> 6 TCP 可靠传输的实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#61-以字节为单位的滑动窗口"><span class="toc_mobile_items-number">6.1.</span> <span class="toc_mobile_items-text"> 6.1 以字节为单位的滑动窗口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#62-超时重传时间的选择"><span class="toc_mobile_items-number">6.2.</span> <span class="toc_mobile_items-text"> 6.2 超时重传时间的选择</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#63-选择确认-sack"><span class="toc_mobile_items-number">6.3.</span> <span class="toc_mobile_items-text"> 6.3 选择确认 SACK</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7-tcp-的流量控制"><span class="toc_mobile_items-number">7.</span> <span class="toc_mobile_items-text"> 7 TCP 的流量控制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#71-利用滑动窗口实现流量控制"><span class="toc_mobile_items-number">7.1.</span> <span class="toc_mobile_items-text"> 7.1 利用滑动窗口实现流量控制</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#72-必须考虑传输效率"><span class="toc_mobile_items-number">7.2.</span> <span class="toc_mobile_items-text"> 7.2 必须考虑传输效率</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#8-tcp的拥塞控制"><span class="toc_mobile_items-number">8.</span> <span class="toc_mobile_items-text"> 8 TCP的拥塞控制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#81-拥塞控制的原理"><span class="toc_mobile_items-number">8.1.</span> <span class="toc_mobile_items-text"> 8.1 拥塞控制的原理</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#82-拥塞控制方法"><span class="toc_mobile_items-number">8.2.</span> <span class="toc_mobile_items-text"> 8.2 拥塞控制方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#821-慢开始和拥塞避免"><span class="toc_mobile_items-number">8.2.1.</span> <span class="toc_mobile_items-text"> 8.2.1 慢开始和拥塞避免</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#822-快重传和快恢复"><span class="toc_mobile_items-number">8.2.2.</span> <span class="toc_mobile_items-text"> 8.2.2 快重传和快恢复</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#83-随机早期检测-red"><span class="toc_mobile_items-number">8.3.</span> <span class="toc_mobile_items-text"> 8.3 随机早期检测 RED</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#9-tcp-的运输连接管理"><span class="toc_mobile_items-number">9.</span> <span class="toc_mobile_items-text"> 9 TCP 的运输连接管理</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#91-tcp-的连接建立"><span class="toc_mobile_items-number">9.1.</span> <span class="toc_mobile_items-text"> 9.1 TCP 的连接建立</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#92-tcp-的连接释放"><span class="toc_mobile_items-number">9.2.</span> <span class="toc_mobile_items-text"> 9.2 TCP 的连接释放</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#93-tcp-的有限状态机"><span class="toc_mobile_items-number">9.3.</span> <span class="toc_mobile_items-text"> 9.3 TCP 的有限状态机</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-运输层协议概述"><span class="toc-number">1.</span> <span class="toc-text"> 1 运输层协议概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-进程之间的通信"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1 进程之间的通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-运输层的两个主要协议"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2 运输层的两个主要协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-运输层的端口"><span class="toc-number">1.3.</span> <span class="toc-text"> 1.3 运输层的端口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-用户数据报协议-udp"><span class="toc-number">2.</span> <span class="toc-text"> 2 用户数据报协议 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-udp-概述"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 UDP 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-udp-的首部格式"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.2 UDP 的首部格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-传输控制协议-tcp-概述"><span class="toc-number">3.</span> <span class="toc-text"> 3 传输控制协议 TCP 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#31-tcp-最主要的特点"><span class="toc-number">3.1.</span> <span class="toc-text"> 3.1 TCP 最主要的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-tcp-的连接"><span class="toc-number">3.2.</span> <span class="toc-text"> 3.2 TCP 的连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-可靠传输的工作原理"><span class="toc-number">4.</span> <span class="toc-text"> 4 可靠传输的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-停止等待协议"><span class="toc-number">4.1.</span> <span class="toc-text"> 4.1 停止等待协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-连续-arq-协议"><span class="toc-number">4.2.</span> <span class="toc-text"> 4.2 连续 ARQ 协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-tcp-报文段的首部格式"><span class="toc-number">5.</span> <span class="toc-text"> 5 TCP 报文段的首部格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-tcp-可靠传输的实现"><span class="toc-number">6.</span> <span class="toc-text"> 6 TCP 可靠传输的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-以字节为单位的滑动窗口"><span class="toc-number">6.1.</span> <span class="toc-text"> 6.1 以字节为单位的滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-超时重传时间的选择"><span class="toc-number">6.2.</span> <span class="toc-text"> 6.2 超时重传时间的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-选择确认-sack"><span class="toc-number">6.3.</span> <span class="toc-text"> 6.3 选择确认 SACK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-tcp-的流量控制"><span class="toc-number">7.</span> <span class="toc-text"> 7 TCP 的流量控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#71-利用滑动窗口实现流量控制"><span class="toc-number">7.1.</span> <span class="toc-text"> 7.1 利用滑动窗口实现流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72-必须考虑传输效率"><span class="toc-number">7.2.</span> <span class="toc-text"> 7.2 必须考虑传输效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-tcp的拥塞控制"><span class="toc-number">8.</span> <span class="toc-text"> 8 TCP的拥塞控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#81-拥塞控制的原理"><span class="toc-number">8.1.</span> <span class="toc-text"> 8.1 拥塞控制的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#82-拥塞控制方法"><span class="toc-number">8.2.</span> <span class="toc-text"> 8.2 拥塞控制方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#821-慢开始和拥塞避免"><span class="toc-number">8.2.1.</span> <span class="toc-text"> 8.2.1 慢开始和拥塞避免</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#822-快重传和快恢复"><span class="toc-number">8.2.2.</span> <span class="toc-text"> 8.2.2 快重传和快恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#83-随机早期检测-red"><span class="toc-number">8.3.</span> <span class="toc-text"> 8.3 随机早期检测 RED</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-tcp-的运输连接管理"><span class="toc-number">9.</span> <span class="toc-text"> 9 TCP 的运输连接管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#91-tcp-的连接建立"><span class="toc-number">9.1.</span> <span class="toc-text"> 9.1 TCP 的连接建立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-tcp-的连接释放"><span class="toc-number">9.2.</span> <span class="toc-text"> 9.2 TCP 的连接释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93-tcp-的有限状态机"><span class="toc-number">9.3.</span> <span class="toc-text"> 9.3 TCP 的有限状态机</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png)"><div id="post-info"><div id="post-title"><div class="posttitle">计算机网络(六)：运输层</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-05<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-05</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/02/05/network-5/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="1-运输层协议概述"><a class="markdownIt-Anchor" href="#1-运输层协议概述"></a> 1 运输层协议概述</h2>
<h3 id="11-进程之间的通信"><a class="markdownIt-Anchor" href="#11-进程之间的通信"></a> 1.1 进程之间的通信</h3>
<p>从通信和信息处理的角度看，<strong>运输层向它上面的应用层提供通信服务</strong>，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p>
<p>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。</p>
<p><a href="/pic/network/5-1.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-1.png" class="lazyload" title></a></p>
<hr>
<p><strong>应用进程之间的通信</strong></p>
<p>两个主机进行通信实际上就是两个主机中的<strong>应用进程互相通信</strong>。</p>
<p>应用进程之间的通信又称为<strong>端到端的通信</strong>。</p>
<p>运输层的一个很重要的功能就是<strong>复用</strong>和<strong>分用</strong>。应用层不同进程的报文通过不同的端口向下交到运输层，再往下就共用网络层提供的服务。</p>
<p>运输层提供应用进程间的<strong>逻辑通信</strong>：“逻辑通信”的意思是运输层之间的通信好像是沿水平方向传送数据。但事实上这两个运输层之间并没有一条水平方向的物理连接。</p>
<p><a href="/pic/network/5-2.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-2.png" class="lazyload" title></a></p>
<hr>
<p><strong>运输层的主要功能</strong></p>
<ol>
<li>运输层为<strong>应用进程之间</strong>提供<strong>端到端</strong>的逻辑通信（但网络层是为<strong>主机之间</strong>提供逻辑通信）。</li>
<li>运输层还要对收到的报文进行差错检测。</li>
<li>运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP。</li>
</ol>
<p><strong>两种不同的运输协议</strong></p>
<p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。</p>
<ul>
<li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</li>
<li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。</li>
</ul>
<h3 id="12-运输层的两个主要协议"><a class="markdownIt-Anchor" href="#12-运输层的两个主要协议"></a> 1.2 运输层的两个主要协议</h3>
<p>TCP/IP 的运输层有两个不同的协议：</p>
<ol>
<li><strong>用户数据报协议 UDP</strong> (User Datagram Protocol)</li>
<li><strong>传输控制协议 TCP</strong> (Transmission Control Protocol)</li>
</ol>
<p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元 TPDU</strong> (Transport Protocol Data Unit)。</p>
<ol>
<li>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>；</li>
<li>UDP 传送的数据单位协议是 <strong>UDP 报文或用户数据报</strong>；</li>
</ol>
<hr>
<p><strong>TCP 与 UDP 的主要区别</strong></p>
<ul>
<li>UDP 在传送数据之前不需要先建立连接。对方的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 是一种最有效的工作方式。</li>
<li>TCP 则提供面向连接的服务。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。</li>
<li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别。IP 数据报要经过互连网中许多路由器的存储转发，但 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的。</li>
<li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</li>
</ul>
<h3 id="13-运输层的端口"><a class="markdownIt-Anchor" href="#13-运输层的端口"></a> 1.3 运输层的端口</h3>
<p>运行在计算机中的进程是用<strong>进程标识符</strong>来标志的。</p>
<p>运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在因特网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。</p>
<p>为了使运行不同操作系统的计算机的应用进程能够互相通信，就<strong>必须用统一的方法</strong>对 TCP/IP 体系的应用进程进行标志。</p>
<hr>
<p><strong>需要解决的问题</strong></p>
<ol>
<li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li>
<li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li>
<li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li>
</ol>
<p><strong>端口号</strong></p>
<p>解决这个问题的方法就是在运输层使用协议端口号，或通常简称为端口(port)。</p>
<p>虽然通信的终点是应用进程，但我们可以把端口想象是通信的终点，因为我们只要把要传送的报文交到目的主机的某一个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 来完成。</p>
<p><strong>软件端口与硬件端口</strong></p>
<ul>
<li>在协议栈层间的抽象的协议端口是软件端口。</li>
<li>路由器或交换机上的端口是硬件端口。</li>
</ul>
<p>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。</p>
<hr>
<p><strong>TCP 的端口</strong></p>
<p>端口用一个 16 位端口号进行标志。端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。在因特网中不同计算机的相同端口号是没有联系的。</p>
<p><strong>三类端口</strong></p>
<ol>
<li>熟知端口：数值一般为 0~1023。</li>
<li>登记端口号：数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li>
<li>客户端口号或短暂端口号：数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li>
</ol>
<h2 id="2-用户数据报协议-udp"><a class="markdownIt-Anchor" href="#2-用户数据报协议-udp"></a> 2 用户数据报协议 UDP</h2>
<h3 id="21-udp-概述"><a class="markdownIt-Anchor" href="#21-udp-概述"></a> 2.1 UDP 概述</h3>
<p>UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即<strong>端口</strong>的功能和<strong>差错检测</strong>的功能。</p>
<p>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p>
<p><strong>UDP 的主要特点</strong></p>
<ul>
<li>UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。</li>
<li>UDP 是面向报文的。UDP 没有拥塞控制，很适合多媒体通信的要求。</li>
<li>UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
<li>UDP 的首部开销小，只有 8 个字节。</li>
</ul>
<p><strong>面向报文的 UDP</strong></p>
<ul>
<li>发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li>
<li>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。</li>
<li>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。</li>
<li>应用程序必须选择合适大小的报文。</li>
</ul>
<p><a href="/pic/network/5-3.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-3.png" class="lazyload" title></a></p>
<h3 id="22-udp-的首部格式"><a class="markdownIt-Anchor" href="#22-udp-的首部格式"></a> 2.2 UDP 的首部格式</h3>
<p><a href="/pic/network/5-4.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-4.png" class="lazyload" title></a></p>
<p>用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节。</p>
<p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。<strong>伪首部仅仅是为了计算检验和</strong>。</p>
<p><a href="/pic/network/5-5.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-5.png" class="lazyload" title></a></p>
<h2 id="3-传输控制协议-tcp-概述"><a class="markdownIt-Anchor" href="#3-传输控制协议-tcp-概述"></a> 3 传输控制协议 TCP 概述</h2>
<h3 id="31-tcp-最主要的特点"><a class="markdownIt-Anchor" href="#31-tcp-最主要的特点"></a> 3.1 TCP 最主要的特点</h3>
<p>TCP 协议的主要特点：</p>
<ul>
<li>TCP 是<strong>面向连接</strong>的运输层协议。</li>
<li>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）。</li>
<li>TCP 提供可靠交付的服务。</li>
<li>TCP 提供全双工通信。</li>
<li>面向字节流。</li>
</ul>
<p><a href="/pic/network/5-6.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-6.png" class="lazyload" title></a></p>
<p><strong>注意事项</strong>：</p>
<ul>
<li>TCP 连接是一条虚连接而不是一条真正的物理连接。</li>
<li>TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。</li>
<li>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。</li>
<li>TCP 可把太长的数据块划分短一些再传送。TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li>
</ul>
<h3 id="32-tcp-的连接"><a class="markdownIt-Anchor" href="#32-tcp-的连接"></a> 3.2 TCP 的连接</h3>
<ul>
<li>TCP 把连接作为最基本的抽象。</li>
<li>每一条 TCP 连接有两个端点。</li>
<li>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字</strong>(socket)或插口。</li>
<li>端口号拼接到 IP 地址即构成了套接字。</li>
</ul>
<pre class="highlight"><code class>套接字 socket = (IP地址: 端口号)
</code></pre>
<p>每一条 <strong>TCP</strong> 连接唯一地被通信两端的两个端点（即两个套接字）所确定。即：</p>
<pre class="highlight"><code class>TCP连接 ::= {socket1, socket2} = {(IP1: port1), (IP2: port2)}     
</code></pre>
<h2 id="4-可靠传输的工作原理"><a class="markdownIt-Anchor" href="#4-可靠传输的工作原理"></a> 4 可靠传输的工作原理</h2>
<h3 id="41-停止等待协议"><a class="markdownIt-Anchor" href="#41-停止等待协议"></a> 4.1 停止等待协议</h3>
<p><a href="/pic/network/5-7.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-7.png" class="lazyload" title></a></p>
<ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本。</li>
<li>分组和确认分组都必须进行编号。</li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li>
</ul>
<p><a href="/pic/network/5-8.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-8.png" class="lazyload" title></a></p>
<p><strong>可靠通信的实现</strong></p>
<p>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</p>
<p>这种可靠传输协议常称为<strong>自动重传请求ARQ</strong> (Automatic Repeat reQuest)。</p>
<p>ARQ 表明重传的请求是<strong>自动</strong>进行的。接收方不需要请求发送方重传某个出错的分组 。</p>
<hr>
<p><strong>信道利用率</strong></p>
<p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p>
<p><a href="/pic/network/5-9.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-9.png" class="lazyload" title></a></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>=</mo><mfrac><msub><mi>T</mi><mi>D</mi></msub><mrow><msub><mi>T</mi><mi>D</mi></msub><mo>+</mo><mi>R</mi><mi>T</mi><mi>T</mi><mo>+</mo><msub><mi>T</mi><mi>A</mi></msub></mrow></mfrac></mrow><annotation encoding="application/x-tex">U=\frac{T_{D}}{T_{D}+RTT+T_{A}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.19633em;vertical-align:-0.8360000000000001em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.3139999999999996em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8360000000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p><strong>流水线传输</strong></p>
<p>发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。</p>
<p>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。</p>
<p><a href="/pic/network/5-10.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-10.png" class="lazyload" title></a></p>
<h3 id="42-连续-arq-协议"><a class="markdownIt-Anchor" href="#42-连续-arq-协议"></a> 4.2 连续 ARQ 协议</h3>
<p><a href="/pic/network/5-11.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-11.png" class="lazyload" title></a></p>
<p><strong>累积确认</strong></p>
<p>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</p>
<p>累积确认有的优点是：容易实现，即使确认丢失也不必重传。缺点是：不能向发送方反映出接收方已经正确收到的所有分组的信息。</p>
<p><strong>Go-back-N（回退 N）</strong></p>
<p>如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</p>
<p>这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 <em>N</em> 个分组。</p>
<p>可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</p>
<hr>
<p><strong>TCP 可靠通信的具体实现</strong></p>
<ul>
<li>TCP 连接的每一端都必须设有两个窗口——一个发送窗口和一个接收窗口。</li>
<li>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</li>
<li>TCP 两端的四个窗口经常处于动态变化之中。</li>
<li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。</li>
</ul>
<h2 id="5-tcp-报文段的首部格式"><a class="markdownIt-Anchor" href="#5-tcp-报文段的首部格式"></a> 5 TCP 报文段的首部格式</h2>
<p><a href="/pic/network/5-12.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-12.png" class="lazyload" title></a></p>
<ul>
<li><strong>源端口和目的端口字段</strong>：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li>
<li><strong>序号字段</strong>：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li>
<li><strong>确认号字段</strong>：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li>
<li><strong>数据偏移</strong>（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li>
<li><strong>保留字段</strong>：占 6 位，保留为今后使用，但目前应置为 0。</li>
<li><strong>紧急 URG</strong>：当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。</li>
<li><strong>确认 ACK</strong>：只有当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</li>
<li><strong>推送 PSH</strong>：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</li>
<li><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。</li>
<li><strong>同步 SYN</strong>：同步 SYN = 1 表示这是一个连接请求或连接接受报文。</li>
<li><strong>终止 FIN</strong>：用来释放一个连接。FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。</li>
<li><strong>窗口字段</strong>：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li>
<li><strong>检验和</strong>：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li>
<li><strong>紧急指针字段</strong>：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li>
<li><strong>选项字段</strong>：长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS</strong>。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<br>
MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。</li>
<li><strong>填充字段</strong>：这是为了使整个首部长度是 4 字节的整数倍。</li>
</ul>
<h2 id="6-tcp-可靠传输的实现"><a class="markdownIt-Anchor" href="#6-tcp-可靠传输的实现"></a> 6 TCP 可靠传输的实现</h2>
<h3 id="61-以字节为单位的滑动窗口"><a class="markdownIt-Anchor" href="#61-以字节为单位的滑动窗口"></a> 6.1 以字节为单位的滑动窗口</h3>
<p>根据 B 给出的窗口值 A 构造出自己的发送窗口。</p>
<p><a href="/pic/network/5-13.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-13.png" class="lazyload" title></a></p>
<p><a href="/pic/network/5-14.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-14.png" class="lazyload" title></a></p>
<p><a href="/pic/network/5-15.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-15.png" class="lazyload" title></a></p>
<p><a href="/pic/network/5-16.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-16.png" class="lazyload" title></a></p>
<hr>
<p><strong>发送缓存和接收缓存</strong></p>
<p><a href="/pic/network/5-17.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-17.png" class="lazyload" title></a></p>
<p>发送缓存与接收缓存的作用：</p>
<ul>
<li>发送缓存用来暂时存放：
<ul>
<li>发送应用程序传送给发送方 TCP 准备发送的数据；</li>
<li>TCP 已发送出但尚未收到确认的数据。</li>
</ul>
</li>
<li>接收缓存用来暂时存放：
<ul>
<li>按序到达的、但尚未被接收应用程序读取的数据；</li>
<li>不按序到达的数据。</li>
</ul>
</li>
</ul>
<p><strong>需要注意的是</strong>：</p>
<ul>
<li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。</li>
</ul>
<h3 id="62-超时重传时间的选择"><a class="markdownIt-Anchor" href="#62-超时重传时间的选择"></a> 6.2 超时重传时间的选择</h3>
<p>重传机制是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</p>
<p><strong>往返时延的方差很大</strong></p>
<p>由于 TCP 的下层是一个互联网环境，IP 数据报所选择的路由变化很大。因而运输层的往返时间的方差也很大。</p>
<p><a href="/pic/network/5-18.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-18.png" class="lazyload" title></a></p>
<hr>
<p><strong>加权平均往返时间</strong></p>
<p>TCP 保留了 RTT 的一个加权平均往返时间 RTT<sub>S</sub>（这又称为平滑的往返时间）。</p>
<p>第一次测量到 RTT 样本时，RTT<sub>S</sub> 值就取为所测量到的 RTT 样本值。以后每测量到一个新的 RTT 样本，就按下式重新计算一次 RTT<sub>S</sub>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>s</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的RTT_{s}=(1-\alpha )\times (旧的RTT_{s})+\alpha \times (新的RTT样本)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose">)</span></span></span></span></span></p>
<p>上式中，0 ≤ a &lt; 1。若 a 很接近于零，表示 RTT 值更新较慢。若选择 a 接近于 1，则表示 RTT 值更新较快。</p>
<p>RFC 2988 推荐的 a 值为 1/8，即 0.125。</p>
<hr>
<p><strong>超时重传时间 RTO</strong></p>
<p>RTO 应略大于上面得出的加权平均往返时间 RTT<sub>S</sub>。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>+</mo><mn>4</mn><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">RTO = RTT_{S}+4\times RTT_{D}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>RTT<sub>D</sub> 是 RTT 的偏差的加权平均值。</p>
<p>RFC 2988 建议这样计算 RTT<sub>D</sub>。第一次测量时，RTT<sub>D</sub> 值取为测量到的 RTT 样本值的一半。在以后的测量中，则使用下式计算加权平均的 RTT<sub>D</sub>：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>β</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>D</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>β</mi><mo>×</mo><mrow><mo fence="true">∣</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo>−</mo><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>T</mi><mi mathvariant="normal">样</mi><mi mathvariant="normal">本</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">新的 RTT_{D} = (1 - \beta ) \times  (旧的RTT_{D}) + \beta  \times  \left | RTT_{S} - 新的 RTT 样本   \right |
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∣</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord cjk_fallback">样</span><span class="mord cjk_fallback">本</span><span class="mclose delimcenter" style="top:0em;">∣</span></span></span></span></span></span></p>
<p>β 是个小于 1 的系数，其推荐值是 1/4，即 0.25。</p>
<hr>
<p><strong>往返时间的测量相当复杂</strong></p>
<p><a href="/pic/network/5-19.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-19.png" class="lazyload" title></a></p>
<p>TCP 报文段 1 没有收到确认。重传（即报文段 2）后，收到了确认报文段 ACK。</p>
<p>如何判定此确认报文段是对原来的报文段 1 的确认，还是对重传的报文段 2 的确认？</p>
<p><strong>Karn 算法</strong></p>
<p>在计算平均往返时间 RTT 时，<strong>只要报文段重传了</strong>，就不采用其往返时间样本。</p>
<p>这样得出的加权平均平均往返时间 RTT<sub>S</sub> 和超时重传时间 RTO 就较准确。</p>
<p><strong>修正的 Karn 算法</strong></p>
<p>报文段每重传一次，就把 RTO 增大一些：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">新</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>O</mi><mo>=</mo><mi>γ</mi><mo>×</mo><mo stretchy="false">(</mo><mi mathvariant="normal">旧</mi><mi mathvariant="normal">的</mi><mi>R</mi><mi>T</mi><mi>O</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">新的 RTO = \gamma  \times  (旧的 RTO)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">新</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord cjk_fallback">旧</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mclose">)</span></span></span></span></span></p>
<p>系数 γ 的典型值是 2 。</p>
<p>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延 RTT 和超时重传时间 RTO 的数值。实践证明，这种策略较为合理。</p>
<h3 id="63-选择确认-sack"><a class="markdownIt-Anchor" href="#63-选择确认-sack"></a> 6.3 选择确认 SACK</h3>
<p>接收方收到了和前面的字节流不连续的两个字节块。如果这些字节的序号都在接收窗口之内，那么接收方就先收下这些数据，但要把这些信息准确地告诉发送方，使发送方不要再重复发送这些已收到的数据。</p>
<p><a href="/pic/network/5-2.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-2.png" class="lazyload" title></a></p>
<ul>
<li>和前后字节不连续的每一个字节块都有两个边界：左边界和右边界。图中用四个指针标记这些边界。</li>
<li>第一个字节块的左边界 L<sub>1</sub> = 1501，但右边界 R<sub>1</sub> = 3001。</li>
<li>左边界指出字节块的第一个字节的序号，但右边界减 1 才是字节块中的最后一个序号。</li>
<li>第二个字节块的左边界 L<sub>2</sub> = 3501，而右边界 R<sub>2</sub> = 4501。</li>
</ul>
<p><strong>RFC 2018 的规定</strong></p>
<ul>
<li>如果要使用选择确认，那么在建立 TCP 连接时，就要在 TCP 首部的选项中加上“允许 SACK”的选项，而双方必须都事先商定好。</li>
<li>如果使用选择确认，那么原来首部中的“确认号字段”的用法仍然不变。只是以后在 TCP 报文段的首部中都增加了 SACK 选项，以便报告收到的不连续的字节块的边界。</li>
<li>由于首部选项的长度最多只有 40 字节，而指明一个边界就要用掉 4 字节，因此在选项中最多只能指明 4 个字节块的边界信息。</li>
</ul>
<h2 id="7-tcp-的流量控制"><a class="markdownIt-Anchor" href="#7-tcp-的流量控制"></a> 7 TCP 的流量控制</h2>
<h3 id="71-利用滑动窗口实现流量控制"><a class="markdownIt-Anchor" href="#71-利用滑动窗口实现流量控制"></a> 7.1 利用滑动窗口实现流量控制</h3>
<p>一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。</p>
<p><strong>流量控制</strong>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</p>
<p>利用<strong>滑动窗口机制</strong>可以很方便地在 TCP 连接上实现流量控制。</p>
<p>流量控制举例：</p>
<p><a href="/pic/network/5-21.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-21.png" class="lazyload" title></a></p>
<hr>
<p><strong>持续计时器</strong></p>
<ul>
<li>TCP 为每一个连接设有一个持续计时器。</li>
<li>只要 TCP 连接的一方收到对方的<strong>零窗口</strong>通知，就启动持续计时器。</li>
<li>若持续计时器设置的时间到期，就发送一个<strong>零窗口探测报文段</strong>（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</li>
<li>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</li>
<li>若窗口不是零，则死锁的僵局就可以打破了。</li>
</ul>
<h3 id="72-必须考虑传输效率"><a class="markdownIt-Anchor" href="#72-必须考虑传输效率"></a> 7.2 必须考虑传输效率</h3>
<p>可以用不同的机制来控制 TCP 报文段的发送时机:</p>
<ol>
<li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li>
<li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送(push)操作。</li>
<li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li>
</ol>
<h2 id="8-tcp的拥塞控制"><a class="markdownIt-Anchor" href="#8-tcp的拥塞控制"></a> 8 TCP的拥塞控制</h2>
<h3 id="81-拥塞控制的原理"><a class="markdownIt-Anchor" href="#81-拥塞控制的原理"></a> 8.1 拥塞控制的原理</h3>
<p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生<strong>拥塞</strong>。</p>
<p>出现资源拥塞的条件：对资源需求的总和 &gt; 可用资源。</p>
<p>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</p>
<p><strong>拥塞控制与流量控制的关系</strong></p>
<p>拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</p>
<p>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
<p>流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。</p>
<p>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><strong>拥塞控制所起的作用</strong></p>
<p><a href="/pic/network/5-22.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-22.png" class="lazyload" title></a></p>
<p><strong>拥塞控制的原理</strong></p>
<p>拥塞控制是很难设计的，因为它是一个动态的（而不是静态的）问题。</p>
<p>当前网络正朝着高速化的方向发展，这很容易出现缓存不够大而造成分组的丢失。但分组的丢失是网络发生拥塞的征兆而不是原因。</p>
<p>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化甚至发生死锁的原因。这点应特别引起重视。</p>
<hr>
<p><strong>开环控制和闭环控制</strong></p>
<p><strong>开环控制</strong>方法就是在设计网络时事先将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。</p>
<p><strong>闭环控制</strong>是基于反馈环路的概念。属于闭环控制的有以下几种措施：</p>
<ul>
<li>监测网络系统以便检测到拥塞在何时、何处发生。</li>
<li>将拥塞发生的信息传送到可采取行动的地方。</li>
<li>调整网络系统的运行以解决出现的问题。</li>
</ul>
<h3 id="82-拥塞控制方法"><a class="markdownIt-Anchor" href="#82-拥塞控制方法"></a> 8.2 拥塞控制方法</h3>
<h4 id="821-慢开始和拥塞避免"><a class="markdownIt-Anchor" href="#821-慢开始和拥塞避免"></a> 8.2.1 慢开始和拥塞避免</h4>
<p>发送方维持一个叫做拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。如再考虑到接收方的接收能力，则发送窗口还可能小于拥塞窗口。</p>
<p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<p><strong>慢开始算法的原理</strong></p>
<ol>
<li>在主机刚刚开始发送报文段时可先设置拥塞窗口 cwnd = 1，即设置为一个最大报文段 MSS 的数值。</li>
<li>在每收到一个对新的报文段的确认后，将拥塞窗口加 1，即增加一个 MSS 的数值。</li>
<li>用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。</li>
</ol>
<p><a href="/pic/network/5-23.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-23.png" class="lazyload" title></a></p>
<p><strong>传输轮次</strong></p>
<ul>
<li>使用慢开始算法后，每经过一个<strong>传输轮次</strong>，拥塞窗口 cwnd 就加倍。</li>
<li>一个传输轮次所经历的时间其实就是往返时间 RTT。</li>
<li>“<strong>传输轮次</strong>”更加强调：把拥塞窗口 cwnd 所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</li>
<li>例如，拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方连续发送 4 个报文段，并收到这 4 个报文段的确认，总共经历的时间。</li>
</ul>
<p><strong>设置慢开始门限状态变量 ssthresh</strong></p>
<p>慢开始门限 ssthresh 的用法如下：</p>
<ul>
<li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li>
<li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li>
<li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
<p><strong>拥塞避免算法</strong>的思路是让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍，使拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p><strong>当网络出现拥塞时</strong></p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。</p>
<p>然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。</p>
<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p>慢开始和拥塞避免算法的实现举例</p>
<p><a href="/pic/network/5-24.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-24.png" class="lazyload" title></a></p>
<p>当 TCP 连接进行初始化时，将拥塞窗口置为 1。图中的窗口单位不使用字节而使用报文段。慢开始门限的初始值设置为 16 个报文段，即 ssthresh = 16。</p>
<p>发送端的发送窗口不能超过拥塞窗口 cwnd 和接收端窗口 rwnd 中的最小值。我们假定接收端窗口足够大，因此现在发送窗口的数值等于拥塞窗口的数值。</p>
<ol>
<li>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为 1，发送第一个报文段 M<sub>0</sub>。</li>
<li>发送端每收到一个确认 ，就把 cwnd 加 1。于是发送端可以接着发送 M<sub>1</sub> 和 M<sub>2</sub> 两个报文段。</li>
<li>接收端共发回两个确认。发送端每收到一个对新报文段的确认，就把发送端的 cwnd 加 1。现在 cwnd 从 2 增大到 4，并可接着发送后面的 4 个报文段。</li>
<li>发送端每收到一个对新报文段的确认，就把发送端的拥塞窗口加 1，因此拥塞窗口 cwnd 随着传输轮次按指数规律增长。</li>
<li>当拥塞窗口 cwnd 增长到慢开始门限值 ssthresh 时（即当 cwnd = 16 时），就改为执行拥塞避免算法，拥塞窗口按线性规律增长。</li>
<li>假定拥塞窗口的数值增长到 24 时，网络出现超时，表明网络拥塞了。</li>
<li>更新后的 ssthresh 值变为 12（即发送窗口数值 24 的一半），拥塞窗口再重新设置为 1，并执行慢开始算法。</li>
<li>当 cwnd = 12 时改为执行拥塞避免算法，拥塞窗口按按线性规律增长，每经过一个往返时延就增加一个 MSS 的大小。</li>
</ol>
<p><strong>乘法减小</strong></p>
<p>“乘法减小“是指不论在慢开始阶段还是拥塞避免阶段，只要出现一次超时（即出现一次网络拥塞），就把慢开始门限值 ssthresh 设置为当前的拥塞窗口值乘以 0.5。</p>
<p>当网络频繁出现拥塞时，ssthresh 值就下降得很快，以大大减少注入到网络中的分组数。</p>
<p><strong>加法增大</strong></p>
<p>“加法增大”是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口 cwnd增加一个 MSS 大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞。</p>
<p><strong>必须强调指出</strong></p>
<ul>
<li>“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li>
<li>“拥塞避免”是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</li>
</ul>
<h4 id="822-快重传和快恢复"><a class="markdownIt-Anchor" href="#822-快重传和快恢复"></a> 8.2.2 快重传和快恢复</h4>
<p><strong>快重传算法</strong></p>
<ol>
<li>首先要求接收方每收到一个失序的报文段后就立即发出重复确认。这样做可以让发送方及早知道有报文段没有到达接收方。</li>
<li>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段。</li>
<li>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</li>
</ol>
<p><a href="/pic/network/5-25.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-25.png" class="lazyload" title></a></p>
<p><strong>快恢复算法</strong></p>
<ol>
<li>当发送端收到连续三个重复的确认时，就执行“乘法减小”算法，把慢开始门限 ssthresh 减半。但接下去不执行慢开始算法。</li>
<li>由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，即拥塞窗口 cwnd 现在不设置为 1，而是设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</li>
</ol>
<p><a href="/pic/network/5-26.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-26.png" class="lazyload" title></a></p>
<p><strong>发送窗口的上限值</strong></p>
<p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p>
<pre class="highlight"><code class>发送窗口的上限值 = Min[rwnd, cwnd]                 
</code></pre>
<ul>
<li>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。</li>
<li>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</li>
</ul>
<h3 id="83-随机早期检测-red"><a class="markdownIt-Anchor" href="#83-随机早期检测-red"></a> 8.3 随机早期检测 RED</h3>
<p>RED 将路由器的到达队列划分成为三个区域。</p>
<p><a href="/pic/network/5-27.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-27.png" class="lazyload" title></a></p>
<ul>
<li>使路由器的队列维持两个参数，即队列长度最小门限 TH<sub>min</sub> 和最大门限 TH<sub>max</sub>。</li>
<li>RED 对每一个到达的数据报都先计算平均队列长度 <em>L</em><sub>AV</sub>。</li>
<li>若平均队列长度小于最小门限 TH<sub>min</sub>，则将新到达的数据报放入队列进行排队。</li>
<li>若平均队列长度超过最大门限 TH<sub>max</sub>，则将新到达的数据报丢弃。</li>
<li>若平均队列长度在最小门限 TH<sub>min</sub> 和最大门限 TH<sub>max</sub> 之间，则按照某一概率 <em>p</em> 将新到达的数据报丢弃。</li>
</ul>
<p><strong>丢弃概率 <em>p</em> 与 TH<sub>min</sub> 和 TH<sub>max</sub> 的关系</strong></p>
<ul>
<li>当 <em>L</em><sub>AV</sub> &lt; TH<sub>min</sub> 时，丢弃概率 <em>p</em> = 0。</li>
<li>当 <em>L</em><sub>AV</sub> &gt;TH<sub>max</sub> 时，丢弃概率 <em>p</em> = 1。</li>
<li>当 TH<sub>min</sub> &lt; <em>L</em><sub>AV</sub> &lt; TH<sub>max</sub>时，  0 &lt; <em>p</em> &lt; 1 。例如，按线性规律变化，从 0 变到 <em>p</em><sub>max</sub>。</li>
</ul>
<p><a href="/pic/network/5-28.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-28.png" class="lazyload" title></a></p>
<h2 id="9-tcp-的运输连接管理"><a class="markdownIt-Anchor" href="#9-tcp-的运输连接管理"></a> 9 TCP 的运输连接管理</h2>
<p>运输连接就有三个阶段，即：<strong>连接建立</strong>、<strong>数据传送</strong>和<strong>连接释放</strong>。运输连接的管理就是使运输连接的建立和释放都能正常地进行。</p>
<p>连接建立过程中要解决以下三个问题：</p>
<ol>
<li>要使每一方能够确知对方的存在；</li>
<li>要允许双方协商一些参数（如最大报文段长度，最大窗口大小，服务质量等）；</li>
<li>能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配；</li>
</ol>
<p><strong>客户服务器方式</strong></p>
<p>TCP 连接的建立都是采用客户服务器方式。</p>
<p>主动发起连接建立的应用进程叫做<strong>客户</strong>(client)。</p>
<p>被动等待连接建立的应用进程叫做<strong>服务器</strong>(server)。</p>
<h3 id="91-tcp-的连接建立"><a class="markdownIt-Anchor" href="#91-tcp-的连接建立"></a> 9.1 TCP 的连接建立</h3>
<p>用三次握手建立 TCP 连接。</p>
<p><a href="/pic/network/5-29.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-29.png" class="lazyload" title></a></p>
<ol>
<li>A 的 TCP 向 B 发出连接请求报文段，其首部中的同步位 SYN = 1，并选择序号 seq = x，表明传送数据时的第一个数据字节的序号是 x。</li>
<li>B 的 TCP 收到连接请求报文段后，如同意，则发回确认；B 在确认报文段中应使 SYN = 1，使 ACK = 1，其确认号ack = x + 1，自己选择的序号 seq = y。</li>
<li>A 收到此报文段后向 B 给出确认，其 ACK = 1，确认号 ack = y + 1；A 的 TCP 通知上层应用进程，连接已经建立。</li>
<li>B 的 TCP 收到主机 A 的确认后，也通知其上层应用进程：TCP 连接已经建立。</li>
</ol>
<h3 id="92-tcp-的连接释放"><a class="markdownIt-Anchor" href="#92-tcp-的连接释放"></a> 9.2 TCP 的连接释放</h3>
<p><a href="/pic/network/5-30.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-30.png" class="lazyload" title></a></p>
<ol>
<li>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的 FIN = 1，其序号seq = u，等待 B 的确认。</li>
<li>B 发出确认，确认号 ack = u + 1，而这个报文段自己的序号 seq = v。TCP 服务器进程通知高层应用进程。从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。B 若发送数据，A 仍要接收。</li>
<li>若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。</li>
<li>A 收到连接释放报文段后，必须发出确认。在确认报文段中 ACK = 1，确认号 ack = w + 1，自己的序号 seq = u + 1。</li>
<li>TCP 连接必须经过时间 2MSL 后才真正释放掉。</li>
</ol>
<p><strong>A 必须等待 2MSL 的时间</strong></p>
<ol>
<li>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。</li>
<li>防止 “已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段，都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</li>
</ol>
<h3 id="93-tcp-的有限状态机"><a class="markdownIt-Anchor" href="#93-tcp-的有限状态机"></a> 9.3 TCP 的有限状态机</h3>
<p>TCP 有限状态机的图中每一个方框都是 TCP 可能具有的状态。</p>
<p>每个方框中的大写英文字符串是 TCP 标准所使用的 TCP 连接状态名。状态之间的箭头表示可能发生的状态变迁。</p>
<p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头。</p>
<ul>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>另一种细线箭头表示异常变迁。</li>
</ul>
<p><a href="/pic/network/5-31.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="/pic/network/5-31.png" class="lazyload" title></a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">fc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://fengce1993.github.io/2020/02/05/network-5/">http://fengce1993.github.io/2020/02/05/network-5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://fengce1993.github.io">BLEACH</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/06/network-6/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>计算机网络(气)：应用层</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/03/network-4-2/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>计算机网络(五)：网络层(二)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/21/network-1/" title="计算机网络(一)：计算机网络概述"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-21</div><div class="relatedPosts_title">计算机网络(一)：计算机网络概述</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/28/network-2/" title="计算机网络(二)：物理层"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-28</div><div class="relatedPosts_title">计算机网络(二)：物理层</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/06/network-6/" title="计算机网络(气)：应用层"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-06</div><div class="relatedPosts_title">计算机网络(气)：应用层</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/30/network-3/" title="计算机网络(三)：数据链路层"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-30</div><div class="relatedPosts_title">计算机网络(三)：数据链路层</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/03/network-4-2/" title="计算机网络(五)：网络层(二)"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-03</div><div class="relatedPosts_title">计算机网络(五)：网络层(二)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/02/network-4-1/" title="计算机网络(四)：网络层(一)"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/top_img/default.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-02</div><div class="relatedPosts_title">计算机网络(四)：网络层(一)</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '98c8aa074b828fc6bd11',
  clientSecret: 'e0e862ca02f30148e7b5f049bd5a736d7831a717',
  repo: 'fengce1993.github.io',
  owner: 'fengce1993',
  admin: 'fengce1993',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By fc</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>$(function () {
  $('span.katex-display').wrap('<div class="katex-wrap"></div>')
})</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>